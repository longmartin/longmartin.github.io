<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>追光者的部落</title>
  
  <subtitle>种一棵树最好的时间是十年之前,其次是现在</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.inbelieve.top/"/>
  <updated>2018-06-17T05:11:58.685Z</updated>
  <id>http://blog.inbelieve.top/</id>
  
  <author>
    <name>Martin Long</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器User-Agent总结</title>
    <link href="http://blog.inbelieve.top/server/20180617-23.html"/>
    <id>http://blog.inbelieve.top/server/20180617-23.html</id>
    <published>2018-06-17T13:07:04.000Z</published>
    <updated>2018-06-17T05:11:58.685Z</updated>
    
    <content type="html"><![CDATA[<p>UserAgent中文名为用户代理，是Http协议中header头的组成部分，UserAgent也简称UA。它是一个特殊字符串头，是一种向访问网站提供你所使用的浏览器类型及版本、操作系统及版本、浏览器内核、等信息的标识。通过这个标识，用户所访问的网站可以显示不同的排版从而为用户提供更好的体验或者进行信息统计；例如用手机访问谷歌和电脑访问是不一样的，这些是谷歌根据访问者的UA来判断的。UA可以进行伪装。</p><blockquote><p>浏览器的UA字串的标准格式：浏览器标识 (操作系统标识 加密等级标识 浏览器语言) 渲染引擎标识版本信息。</p></blockquote><h4 id="字串说明："><a href="#字串说明：" class="headerlink" title="字串说明："></a>字串说明：</h4><h5 id="1、浏览器标识"><a href="#1、浏览器标识" class="headerlink" title="1、浏览器标识"></a>1、浏览器标识</h5><p>出于兼容及推广等目的，很多浏览器的标识相同（如Mozilla/5.0），因此浏览器标识并不能说明浏览器的真实版本，真实版本信息在UA字串尾部可以找到。</p><h5 id="2、操作系统标识"><a href="#2、操作系统标识" class="headerlink" title="2、操作系统标识"></a>2、操作系统标识</h5><table><thead><tr><th style="text-align:center">平台</th><th style="text-align:left">标识</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">FreeBSD</td><td style="text-align:left">X11</td><td style="text-align:left">FreeBSD(version no.)i386</td></tr><tr><td style="text-align:center">FreeBSD</td><td style="text-align:left">X11</td><td style="text-align:left">FreeBSD(version no.)AMD64</td></tr><tr><td style="text-align:center">Linux</td><td style="text-align:left">X11</td><td style="text-align:left">Linux ppc</td></tr><tr><td style="text-align:center">Linux</td><td style="text-align:left">X11</td><td style="text-align:left">Linux ppc64</td></tr><tr><td style="text-align:center">Linux</td><td style="text-align:left">X11</td><td style="text-align:left">Linux i686</td></tr><tr><td style="text-align:center">Linux</td><td style="text-align:left">X11</td><td style="text-align:left">Linux x86_64</td></tr><tr><td style="text-align:center">Mac</td><td style="text-align:left">Macintosh</td><td style="text-align:left">PPC Mac OS X</td></tr><tr><td style="text-align:center">Mac</td><td style="text-align:left">Macintosh</td><td style="text-align:left">Intel Mac OS X</td></tr><tr><td style="text-align:center">Solaris</td><td style="text-align:left">X11</td><td style="text-align:left">SunOS i86pc</td></tr><tr><td style="text-align:center">Solaris</td><td style="text-align:left">X11</td><td style="text-align:left">SunOS sun4u</td></tr><tr><td style="text-align:center">Windows</td><td style="text-align:left">Windows NT 10.0</td><td style="text-align:left">windows 10</td></tr><tr><td style="text-align:center">Windows</td><td style="text-align:left">Windows NT 6.1</td><td style="text-align:left">windows 7</td></tr><tr><td style="text-align:center">Windows</td><td style="text-align:left">Windows NT 6.0</td><td style="text-align:left">windows Vista</td></tr><tr><td style="text-align:center">Windows</td><td style="text-align:left">Windows NT 5.2</td><td style="text-align:left">windows 2003</td></tr><tr><td style="text-align:center">Windows</td><td style="text-align:left">Windows NT 5.1</td><td style="text-align:left">windows xp</td></tr><tr><td style="text-align:center">Windows</td><td style="text-align:left">Windows NT 5.0</td><td style="text-align:left">windows 2000</td></tr></tbody></table><h5 id="3、加密等级标识"><a href="#3、加密等级标识" class="headerlink" title="3、加密等级标识"></a>3、加密等级标识</h5><ul><li>N:表示无安全加密</li><li>I:表示弱安全加密</li><li>U:表示强安全加密</li></ul><h5 id="4、浏览器语言"><a href="#4、浏览器语言" class="headerlink" title="4、浏览器语言"></a>4、浏览器语言</h5><p>在首选项&gt;常规&gt;语言中指定的语言</p><h5 id="5、渲染引擎"><a href="#5、渲染引擎" class="headerlink" title="5、渲染引擎"></a>5、渲染引擎</h5><p>显示浏览器使用的主流渲染引擎有：Gecko、WebKit、KHTML、Presto、Trident、Tasman等，格式为：渲染引擎/版本信息</p><h5 id="6、版本信息"><a href="#6、版本信息" class="headerlink" title="6、版本信息"></a>6、版本信息</h5><p>显示浏览器的真实版本信息，格式为：浏览器/版本信息</p><h4 id="浏览器User-Agent的详细信息"><a href="#浏览器User-Agent的详细信息" class="headerlink" title="浏览器User-Agent的详细信息"></a>浏览器User-Agent的详细信息</h4><h5 id="PC端："><a href="#PC端：" class="headerlink" title="PC端："></a>PC端：</h5><ul><li><p>safari5.1–MAC<br>User-Agent:Mozilla/5.0(Macintosh;U;IntelMacOSX10_6_8;en-us)AppleWebKit/534.50(KHTML,likeGecko)Version/5.1Safari/534.50</p></li><li><p>safari5.1–Windows<br>User-Agent:Mozilla/5.0(Windows;U;WindowsNT6.1;en-us)AppleWebKit/534.50(KHTML,likeGecko)Version/5.1Safari/534.50</p></li><li><p>IE9.0<br>User-Agent:Mozilla/5.0(compatible;MSIE9.0;WindowsNT6.1;Trident/5.0;</p></li><li><p>IE8.0<br>User-Agent:Mozilla/4.0(compatible;MSIE8.0;WindowsNT6.0;Trident/4.0)</p></li><li><p>IE7.0<br>User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT6.0)</p></li><li><p>IE6.0<br>User-Agent:Mozilla/4.0(compatible;MSIE6.0;WindowsNT5.1)</p></li><li><p>Firefox4.0.1–MAC<br>User-Agent:Mozilla/5.0(Macintosh;IntelMacOSX10.6;rv:2.0.1)Gecko/20100101Firefox/4.0.1</p></li><li><p>Firefox4.0.1–Windows<br>User-Agent:Mozilla/5.0(WindowsNT6.1;rv:2.0.1)Gecko/20100101Firefox/4.0.1</p></li><li><p>Opera11.11–MAC<br>User-Agent:Opera/9.80(Macintosh;IntelMacOSX10.6.8;U;en)Presto/2.8.131Version/11.11</p></li><li><p>Opera11.11–Windows<br>User-Agent:Opera/9.80(WindowsNT6.1;U;en)Presto/2.8.131Version/11.11</p></li><li><p>Chrome17.0–MAC<br>User-Agent:Mozilla/5.0(Macintosh;IntelMacOSX10_7_0)AppleWebKit/535.11(KHTML,likeGecko)Chrome/17.0.963.56Safari/535.11</p></li><li><p>傲游（Maxthon）<br>User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;Maxthon2.0)</p></li><li><p>腾讯TT<br>User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;TencentTraveler4.0)</p></li><li><p>世界之窗（TheWorld）2.x<br>User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1)</p></li><li><p>世界之窗（TheWorld）3.x<br>User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;TheWorld)</p></li><li><p>搜狗浏览器1.x<br>User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;Trident/4.0;SE2.XMetaSr1.0;SE2.XMetaSr1.0;.NETCLR2.0.50727;SE2.XMetaSr1.0)</p></li><li><p>360浏览器<br>User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;360SE)</p></li><li><p>Avant<br>User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;AvantBrowser)</p></li><li><p>GreenBrowser<br>User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1)</p></li></ul><h5 id="移动设备端："><a href="#移动设备端：" class="headerlink" title="移动设备端："></a>移动设备端：</h5><ul><li><p>safariiOS4.33–iPhone<br>User-Agent:Mozilla/5.0(iPhone;U;CPUiPhoneOS4_3_3likeMacOSX;en-us)AppleWebKit/533.17.9(KHTML,likeGecko)Version/5.0.2Mobile/8J2Safari/6533.18.5</p></li><li><p>safariiOS4.33–iPodTouch<br>User-Agent:Mozilla/5.0(iPod;U;CPUiPhoneOS4_3_3likeMacOSX;en-us)AppleWebKit/533.17.9(KHTML,likeGecko)Version/5.0.2Mobile/8J2Safari/6533.18.5</p></li><li><p>safariiOS4.33–iPad<br>User-Agent:Mozilla/5.0(iPad;U;CPUOS4_3_3likeMacOSX;en-us)AppleWebKit/533.17.9(KHTML,likeGecko)Version/5.0.2Mobile/8J2Safari/6533.18.5</p></li><li><p>AndroidN1<br>User-Agent:Mozilla/5.0(Linux;U;Android2.3.7;en-us;NexusOneBuild/FRF91)AppleWebKit/533.1(KHTML,likeGecko)Version/4.0MobileSafari/533.1</p></li><li><p>AndroidQQ浏览器Forandroid<br>User-Agent:MQQBrowser/26Mozilla/5.0(Linux;U;Android2.3.7;zh-cn;MB200Build/GRJ22;CyanogenMod-7)AppleWebKit/533.1(KHTML,likeGecko)Version/4.0MobileSafari/533.1</p></li><li><p>AndroidOperaMobile<br>User-Agent:Opera/9.80(Android2.3.4;Linux;OperaMobi/build-1107180945;U;en-GB)Presto/2.8.149Version/11.10</p></li><li><p>AndroidPadMotoXoom<br>User-Agent:Mozilla/5.0(Linux;U;Android3.0;en-us;XoomBuild/HRI39)AppleWebKit/534.13(KHTML,likeGecko)Version/4.0Safari/534.13</p></li><li><p>BlackBerry<br>User-Agent:Mozilla/5.0(BlackBerry;U;BlackBerry9800;en)AppleWebKit/534.1+(KHTML,likeGecko)Version/6.0.0.337MobileSafari/534.1+</p></li><li><p>WebOSHPTouchpad<br>User-Agent:Mozilla/5.0(hp-tablet;Linux;hpwOS/3.0.0;U;en-US)AppleWebKit/534.6(KHTML,likeGecko)wOSBrowser/233.70Safari/534.6TouchPad/1.0</p></li><li><p>NokiaN97<br>User-Agent:Mozilla/5.0(SymbianOS/9.4;Series60/5.0NokiaN97-1/20.0.019;Profile/MIDP-2.1Configuration/CLDC-1.1)AppleWebKit/525(KHTML,likeGecko)BrowserNG/7.1.18124</p></li><li><p>WindowsPhoneMango<br>User-Agent:Mozilla/5.0(compatible;MSIE9.0;WindowsPhoneOS7.5;Trident/5.0;IEMobile/9.0;HTC;Titan)</p></li><li><p>UC无<br>User-Agent:UCWEB7.0.2.37/28/999</p></li><li><p>UC标准<br>User-Agent:NOKIA5700/UCWEB7.0.2.37/28/999</p></li><li><p>UCOpenwave<br>User-Agent:Openwave/UCWEB7.0.2.37/28/999</p></li><li><p>UCOpera<br>User-Agent:Mozilla/4.0(compatible;MSIE6.0;)Opera/UCWEB7.0.2.37/28/999</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UserAgent中文名为用户代理，是Http协议中header头的组成部分，UserAgent也简称UA。它是一个特殊字符串头，是一种向访问网站提供你所使用的浏览器类型及版本、操作系统及版本、浏览器内核、等信息的标识。通过这个标识，用户所访问的网站可以显示不同的排版从而为
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="HTTP" scheme="http://blog.inbelieve.top/tags/http/"/>
    
      <category term="HTML5" scheme="http://blog.inbelieve.top/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://blog.inbelieve.top/server/20180617-22.html"/>
    <id>http://blog.inbelieve.top/server/20180617-22.html</id>
    <published>2018-06-17T13:06:49.000Z</published>
    <updated>2018-06-17T05:11:48.542Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">100</td><td style="text-align:left">客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td></tr><tr><td style="text-align:center">101</td><td style="text-align:left">服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td></tr><tr><td style="text-align:center">102</td><td style="text-align:left">由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td></tr><tr><td style="text-align:center">200</td><td style="text-align:left">请求已成功，请求所希望的响应头或数据体将随此响应返回。</td></tr><tr><td style="text-align:center">201</td><td style="text-align:left">请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td></tr><tr><td style="text-align:center">202</td><td style="text-align:left">服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td></tr><tr><td style="text-align:center">203</td><td style="text-align:left">服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td></tr><tr><td style="text-align:center">204</td><td style="text-align:left">服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td style="text-align:center">205</td><td style="text-align:left">服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td style="text-align:center">206</td><td style="text-align:left">服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td></tr><tr><td style="text-align:center">207</td><td style="text-align:left">由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td style="text-align:center">300</td><td style="text-align:left">被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td style="text-align:center">301</td><td style="text-align:left">被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td></tr><tr><td style="text-align:center">302</td><td style="text-align:left">请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td style="text-align:center">303</td><td style="text-align:left">对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td></tr><tr><td style="text-align:center">304</td><td style="text-align:left">如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td></tr><tr><td style="text-align:center">305</td><td style="text-align:left">被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td style="text-align:center">306</td><td style="text-align:left">在最新版的规范中，306状态码已经不再被使用。</td></tr><tr><td style="text-align:center">307</td><td style="text-align:left">请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td style="text-align:center">400</td><td style="text-align:left">1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。</td></tr><tr><td style="text-align:center">401</td><td style="text-align:left">当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td></tr><tr><td style="text-align:center">402</td><td style="text-align:left">该状态码是为了将来可能的需求而预留的。</td></tr><tr><td style="text-align:center">403</td><td style="text-align:left">服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td style="text-align:center">404</td><td style="text-align:left">请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td style="text-align:center">405</td><td style="text-align:left">请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td style="text-align:center">406</td><td style="text-align:left">请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td style="text-align:center">407</td><td style="text-align:left">　与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td></tr><tr><td style="text-align:center">408</td><td style="text-align:left">请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td style="text-align:center">409</td><td style="text-align:left">由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td></tr><tr><td style="text-align:center">410</td><td style="text-align:left">被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td></tr><tr><td style="text-align:center">411</td><td style="text-align:left">服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td></tr><tr><td style="text-align:center">412</td><td style="text-align:left">服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td style="text-align:center">413</td><td style="text-align:left">服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td style="text-align:center">414</td><td style="text-align:left">请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td style="text-align:center">415</td><td style="text-align:left">对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td style="text-align:center">416</td><td style="text-align:left">如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td></tr><tr><td style="text-align:center">417</td><td style="text-align:left">在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td></tr><tr><td style="text-align:center">421</td><td style="text-align:left">从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td style="text-align:center">422</td><td style="text-align:left">从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td style="text-align:center">422</td><td style="text-align:left">请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV）</td></tr><tr><td style="text-align:center">424</td><td style="text-align:left">由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td></tr><tr><td style="text-align:center">425</td><td style="text-align:left">在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td></tr><tr><td style="text-align:center">426</td><td style="text-align:left">客户端应当切换到TLS/1.0。（RFC 2817）</td></tr><tr><td style="text-align:center">449</td><td style="text-align:left">由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td></tr><tr><td style="text-align:center">500</td><td style="text-align:left">服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td></tr><tr><td style="text-align:center">501</td><td style="text-align:left">服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td></tr><tr><td style="text-align:center">502</td><td style="text-align:left">作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td style="text-align:center">503</td><td style="text-align:left">由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td></tr><tr><td style="text-align:center">504</td><td style="text-align:left">作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td></tr><tr><td style="text-align:center">505</td><td style="text-align:left">服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td style="text-align:center">506</td><td style="text-align:left">由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td style="text-align:center">507</td><td style="text-align:left">服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td style="text-align:center">509</td><td style="text-align:left">服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td style="text-align:center">510</td><td style="text-align:left">获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;状态码&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="HTTP" scheme="http://blog.inbelieve.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>linux上安装SS</title>
    <link href="http://blog.inbelieve.top/server/20180617-21.html"/>
    <id>http://blog.inbelieve.top/server/20180617-21.html</id>
    <published>2018-06-17T13:06:13.000Z</published>
    <updated>2018-06-17T05:11:50.285Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><ul><li><p>centos(如果python版本过低，请升级到2.7)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure></li><li><p>debian/ubantu</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update </span><br><span class="line">sudo apt install python-gevent python-pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch /etc/shadowsocks.json</span><br><span class="line">vim /etc/shadowsocks.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;port_password&quot;:&#123;</span><br><span class="line">        &quot;9001&quot;:&quot;abcdef&quot;,</span><br><span class="line">        &quot;9001&quot;:&quot;abcdef&quot;,</span><br><span class="line">        &quot;9002&quot;:&quot;abcdef&quot;,</span><br><span class="line">        &quot;9003&quot;:&quot;abcdef&quot;  </span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;:600,</span><br><span class="line">    &quot;method&quot;:&quot;rc4-md5&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-启动"><a href="#3-启动" class="headerlink" title="3. 启动"></a>3. 启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure><h3 id="4-设置开机启动，再-etc-rc-local中添加启动命令"><a href="#4-设置开机启动，再-etc-rc-local中添加启动命令" class="headerlink" title="4. 设置开机启动，再 /etc/rc.local中添加启动命令"></a>4. 设置开机启动，再 /etc/rc.local中添加启动命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/rc.local</span><br><span class="line">sudo /usr/local/bin/ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1. 安装&quot;&gt;&lt;/a&gt;1. 安装&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;centos(如果python版本过低，请升级到2.7)&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Linux" scheme="http://blog.inbelieve.top/tags/linux/"/>
    
      <category term="Centos" scheme="http://blog.inbelieve.top/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>浅谈javascript中的订阅发布模式</title>
    <link href="http://blog.inbelieve.top/server/20180617-20.html"/>
    <id>http://blog.inbelieve.top/server/20180617-20.html</id>
    <published>2018-06-17T13:05:53.000Z</published>
    <updated>2018-06-17T05:10:57.943Z</updated>
    
    <content type="html"><![CDATA[<p>事件驱动作为javascript的一个重大特性，而事件驱动的实现原理正是订阅发布模式，本文为大家奉献简单的订阅发布模式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var PubSub = &#123;</span><br><span class="line">    handlers: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PubSub.on = function(eventType, handler) &#123;</span><br><span class="line">    if(!(eventType in this.handlers)) &#123;</span><br><span class="line">        this.handlers[eventType] = []</span><br><span class="line">    &#125;</span><br><span class="line">    this.handlers[eventType].push(handler)</span><br><span class="line">    return this </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PubSub.emit = function(eventType) &#123;</span><br><span class="line">    var handlerArgs = [].protoType.slice.call(arguments, 1)</span><br><span class="line">    for(var i = 0; i &lt; this.handlers[eventType].length; i++) &#123;</span><br><span class="line">        this.handlers[eventType][i].apply(this, handlerArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PubSub.off = function(eventType, handler) &#123;</span><br><span class="line">    if(!(eventType in this.handlers)) &#123; </span><br><span class="line">        return</span><br><span class="line">    &#125;    </span><br><span class="line">    if(handler == undefined) &#123;</span><br><span class="line">        delete this.handlers[eventType]</span><br><span class="line">    &#125;</span><br><span class="line">    var index = this.handlers[eventType].indexOf(handler)    </span><br><span class="line">    if(index !== -1) &#123;</span><br><span class="line">        this.handlers[eventType].splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Pubsub对象实现事件的绑定，解绑，触发等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事件驱动作为javascript的一个重大特性，而事件驱动的实现原理正是订阅发布模式，本文为大家奉献简单的订阅发布模式。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="JavaScript" scheme="http://blog.inbelieve.top/tags/javascript/"/>
    
      <category term="设计模式" scheme="http://blog.inbelieve.top/tags/mode/"/>
    
  </entry>
  
  <entry>
    <title>ip地址类别和私有网段</title>
    <link href="http://blog.inbelieve.top/server/20180617-19.html"/>
    <id>http://blog.inbelieve.top/server/20180617-19.html</id>
    <published>2018-06-17T11:09:48.000Z</published>
    <updated>2018-06-17T05:08:11.865Z</updated>
    
    <content type="html"><![CDATA[<p>我们常用路由器或者虚拟机，发现基本我们的内网都是192.168.x.x或者是10.104.x.x的网关，为什么我们的路由器长设置成这个网关的呢，这就跟计算机网络的私有网段有关系</p><p>互联网上的IP地址统一由一个叫IANA(Internet Assigned Numbers Authority，互联网网络号分配机构)的组织来管理。根据用途和安全性级别的不同，IP地址还可以大致分为两类：公共地址（public IP address）和私有地址（private IP address，也译作保留地址）。公用地址在Internet中使用，可以在Internet中随意访问。私有地址只能在内部网络中使用，只有通过代理服务器才能与Internet通信。</p><p>下面是各类网段ip范围 （“[”表示包含，“）”不包含）：</p><hr><table><thead><tr><th>类别</th><th style="text-align:center">IP前4位/x</th><th style="text-align:right">十进制范围</th></tr></thead><tbody><tr><td>A</td><td style="text-align:center">(0000, 1000)/8</td><td style="text-align:right">[1, 128)</td></tr><tr><td>B</td><td style="text-align:center">[1000, 1100)/16</td><td style="text-align:right">[128, 192)</td></tr><tr><td>C</td><td style="text-align:center">[1100, 1110)/24</td><td style="text-align:right">[192, 224)</td></tr><tr><td>D(多播)</td><td style="text-align:center">[1110, 1111)</td><td style="text-align:right">[224, 240)</td></tr><tr><td>E(保留)</td><td style="text-align:center">[1111, 1111]</td><td style="text-align:right">[240, 255)</td></tr></tbody></table><p>私有网络ip范围：</p><table><thead><tr><th>类别</th><th style="text-align:center">IP范围</th><th style="text-align:right">网络数量</th></tr></thead><tbody><tr><td>A</td><td style="text-align:center">10.0.0.0  ~ 10.255.255.255 (10/8 prefix)</td><td style="text-align:right">1</td></tr><tr><td>B</td><td style="text-align:center">17.16.0.0  ~ 17.32.255.255 (17.16/16 prefix)</td><td style="text-align:right">16</td></tr><tr><td>C</td><td style="text-align:center">192.168.0.0  ~ 1192.168.255.255 (192.168/24 prefix)</td><td style="text-align:right">255</td></tr></tbody></table><p>此外，比较特殊的ip地址有下面几个 </p><ol><li>0.0.0.0 次地址一般用于路由器的默认转发项； </li><li>255.255.255.255 一般用作同一局域网下 的广播地址； </li><li>127.0.0.1 用于回环测试的地址</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们常用路由器或者虚拟机，发现基本我们的内网都是192.168.x.x或者是10.104.x.x的网关，为什么我们的路由器长设置成这个网关的呢，这就跟计算机网络的私有网段有关系&lt;/p&gt;
&lt;p&gt;互联网上的IP地址统一由一个叫IANA(Internet Assigned Num
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="HTTP" scheme="http://blog.inbelieve.top/tags/http/"/>
    
      <category term="Web服务器" scheme="http://blog.inbelieve.top/tags/webserver/"/>
    
  </entry>
  
  <entry>
    <title>composer设置国内镜像</title>
    <link href="http://blog.inbelieve.top/server/20180617-18.html"/>
    <id>http://blog.inbelieve.top/server/20180617-18.html</id>
    <published>2018-06-17T11:06:04.000Z</published>
    <updated>2018-06-17T03:09:01.752Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为使用composer安装依赖，发现比较慢(因为墙的原因)，所以找了一下国内镜像地址配置下，这样可以加快下载速度，方法如下：</p><p>在linux或window的命令行，输入下面命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为使用composer安装依赖，发现比较慢(因为墙的原因)，所以找了一下国内镜像地址配置下，这样可以加快下载速度，方法如下：&lt;/p&gt;
&lt;p&gt;在linux或window的命令行，输入下面命令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="PHP" scheme="http://blog.inbelieve.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Composer设置忽略版本匹配</title>
    <link href="http://blog.inbelieve.top/server/20180617-17.html"/>
    <id>http://blog.inbelieve.top/server/20180617-17.html</id>
    <published>2018-06-17T11:03:07.000Z</published>
    <updated>2018-06-17T03:08:41.809Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用composer安装时发现提示php的版本不匹配。执行composer install遇到错误：Your requirements could not be resolved to an installable set of packages. 这是因为不匹配composer.json要求的版本。</p><p>完整错误如下：</p><p>[PHP]<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vagrant@homestead:/usr/share/nginx/html/laravel-1$ sudo composer install</span><br><span class="line">Loading composer repositories with package information</span><br><span class="line">Installing dependencies (including require-dev) from lock file</span><br><span class="line">Your requirements could not be resolved to an installable set of packages.</span><br><span class="line"></span><br><span class="line">  Problem 1</span><br><span class="line">    - Installation request for doctrine/instantiator 1.0.3 -&gt; satisfiable by doctrine/instantiator[1.0.3].</span><br><span class="line">    - doctrine/instantiator 1.0.3 requires php ~5.3 -&gt; your PHP version (7.0.3) does not satisfy that requirement.</span><br><span class="line">  Problem 2</span><br><span class="line">    - doctrine/instantiator 1.0.3 requires php ~5.3 -&gt; your PHP version (7.0.3) does not satisfy that requirement.</span><br><span class="line">    - phpunit/phpunit-mock-objects 2.3.0 requires doctrine/instantiator ~1.0,&gt;=1.0.1 -&gt; satisfiable by doctrine/instantiator[1.0.3].</span><br><span class="line">    - Installation request for phpunit/phpunit-mock-objects 2.3.0 -&gt; satisfiable by phpunit/phpunit-mock-objects[2.3.0].</span><br></pre></td></tr></table></figure></p><p>提示我的PHP 7版本太高，不符合composer.json需要的版本，但是在PHP 7下应该也是可以运行的，composer可以设置忽略版本匹配，命令是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">composer install --ignore-platform-reqs</span><br></pre></td></tr></table></figure></p><p>or<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">composer update --ignore-platform-reqs</span><br></pre></td></tr></table></figure></p><p>再次执行composer命令可以正常安装包了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近使用composer安装时发现提示php的版本不匹配。执行composer install遇到错误：Your requirements could not be resolved to an installable set of packages. 这是因为不匹配com
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="PHP" scheme="http://blog.inbelieve.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php获取客户端IP</title>
    <link href="http://blog.inbelieve.top/server/20180617-16.html"/>
    <id>http://blog.inbelieve.top/server/20180617-16.html</id>
    <published>2018-06-17T11:02:52.000Z</published>
    <updated>2018-06-17T03:08:18.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="比较-HTTP-CLIENT-IP-HTTP-X-FORWARDED-FOR-REMOTE-ADDR"><a href="#比较-HTTP-CLIENT-IP-HTTP-X-FORWARDED-FOR-REMOTE-ADDR" class="headerlink" title="比较  HTTP_CLIENT_IP HTTP_X_FORWARDED_FOR REMOTE_ADDR"></a>比较  <code>HTTP_CLIENT_IP</code> <code>HTTP_X_FORWARDED_FOR</code> <code>REMOTE_ADDR</code></h3><p>最近做项目的时候，遇到一个需要记录客户端ip的，后台语言是php,我想了一下，用<code>REMOTE_ADDR</code>吧。可是呢，后来发现其实这个还有很多其他的获取方式，<code>HTTP_CLIENT_IP</code>, <code>HTTP_X_FORWARDED_FOR</code>都可以获取，我仔细查了一下资料，总结一下这三者的区别，另附完整解决方法：</p><ol><li><code>HTTP_CLIENT_IP</code>头是有的，只是未成标准，不一定服务器都实现了。</li><li><code>HTTP_X_FORWARDED_FOR</code> 是有标准定义，用来识别经过<code>HTTP代理</code>后的客户端IP地址，格式：<code>clientip,proxy1,proxy2</code>。详细解释见 <a href="http://zh.wikipedia.org/wiki/X-Forwarded-For" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/X-Forwarded-For</a></li><li><code>REMOTE_ADDR</code> 是可靠的， 它是最后一个跟你的服务器握手的<code>IP</code>，可能是用户的代理服务器，也可能是自己的反向代理。</li></ol><p>顺便说下$_SERVER和getenv的区别，getenv不支持IIS的isapi方式运行的php<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getIp() &#123;</span><br><span class="line">    if (getenv ( &quot;HTTP_CLIENT_IP&quot; ) &amp;&amp; strcasecmp ( getenv ( &quot;HTTP_CLIENT_IP&quot; ), &quot;unknown&quot; )) &#123;</span><br><span class="line">        $ip = getenv ( &quot;HTTP_CLIENT_IP&quot; );</span><br><span class="line">    &#125; elseif (getenv ( &quot;HTTP_X_FORWARDED_FOR&quot; ) &amp;&amp; strcasecmp ( getenv ( &quot;HTTP_X_FORWARDED_FOR&quot; ), &quot;unknown&quot; )) &#123;</span><br><span class="line">        $ip = getenv ( &quot;HTTP_X_FORWARDED_FOR&quot; );</span><br><span class="line">    &#125; elseif (getenv ( &quot;REMOTE_ADDR&quot; ) &amp;&amp; strcasecmp ( getenv ( &quot;REMOTE_ADDR&quot; ), &quot;unknown&quot; )) &#123;</span><br><span class="line">        $ip = getenv ( &quot;REMOTE_ADDR&quot; );</span><br><span class="line">    &#125; elseif (isset ( $_SERVER [&apos;REMOTE_ADDR&apos;] ) &amp;&amp; $_SERVER [&apos;REMOTE_ADDR&apos;] &amp;&amp; strcasecmp ( $_SERVER [&apos;REMOTE_ADDR&apos;], &quot;unknown&quot; )) &#123;</span><br><span class="line">        $ip = $_SERVER [&apos;REMOTE_ADDR&apos;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $ip = &quot;unknown&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return ($ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>REMOTE_ADDR</code>不可以显式的伪造，虽然可以通过代理将ip地址隐藏，但是这个地址仍然具有参考价值，因为它就是与你的服务器实际连接的ip地址。</p><p>相比之下，前两种ip地址都可以通过http header来伪造，但并不意味着它们一无是处。生产环境中很多服务器隐藏在负载均衡节点后面，你通过<code>REMOTE_ADDR</code>只能获取到负载均衡节点的ip地址，一般的负载均衡节点会把前端实际的ip地址通过<code>HTTP_CLIENT_IP</code>或者<code>HTTP_X_FORWARDED_FOR</code>这两种http头传递过来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;比较-HTTP-CLIENT-IP-HTTP-X-FORWARDED-FOR-REMOTE-ADDR&quot;&gt;&lt;a href=&quot;#比较-HTTP-CLIENT-IP-HTTP-X-FORWARDED-FOR-REMOTE-ADDR&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="PHP" scheme="http://blog.inbelieve.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>js数组之forEach,every,some,filter,map的区别</title>
    <link href="http://blog.inbelieve.top/frontend/20180617-15.html"/>
    <id>http://blog.inbelieve.top/frontend/20180617-15.html</id>
    <published>2018-06-17T09:27:45.000Z</published>
    <updated>2018-06-17T03:02:04.087Z</updated>
    
    <content type="html"><![CDATA[<p>js数组有很多操作方法，其中forEach,every,some,filter,map是常容易混淆用法的，下面我来解释其中的区别<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var list = [&#123;</span><br><span class="line">&quot;id&quot;: 1,</span><br><span class="line">&quot;age&quot;: 19</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;: 2,</span><br><span class="line">&quot;age&quot;: 18</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">var result = list.forEach((val,index) =&gt; &#123;</span><br><span class="line">val.id = val.id + 1</span><br><span class="line">//return  </span><br><span class="line">&#125;)</span><br><span class="line">console.error(result, list)</span><br><span class="line"></span><br><span class="line">var boolData = list.every(val =&gt; &#123;</span><br><span class="line">return val.age &gt; 18</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.error(boolData, list);</span><br><span class="line"></span><br><span class="line">var boolData2 = list.some(val =&gt; &#123;</span><br><span class="line">return val.age &gt; 18</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.error(boolData2, list);</span><br><span class="line"></span><br><span class="line">var data = list.filter(val =&gt; &#123;</span><br><span class="line">return val.age &gt; 18</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.error(data, list);</span><br><span class="line"></span><br><span class="line">var mapData = list.map(val =&gt; &#123;</span><br><span class="line">return (val.id) * 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.error(mapData, list);</span><br></pre></td></tr></table></figure></p><blockquote><p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined, [ &#123; id: 2, age: 19 &#125;, &#123; id: 3, age: 18 &#125; ]                      #forEach</span><br><span class="line"></span><br><span class="line">false, [ &#123; id: 2, age: 19 &#125;, &#123; id: 3, age: 18 &#125; ]                          #every</span><br><span class="line"></span><br><span class="line">true, [ &#123; id: 2, age: 19 &#125;, &#123; id: 3, age: 18 &#125; ]                           #some</span><br><span class="line"></span><br><span class="line">[ &#123; id: 2, age: 19 &#125; ], [ &#123; id: 2, age: 19 &#125;, &#123; id: 3, age: 18 &#125; ]         #filter</span><br><span class="line"></span><br><span class="line">[ 4, 6 ], [ &#123; id: 2, age: 19 &#125;, &#123; id: 3, age: 18 &#125; ]                       #map</span><br></pre></td></tr></table></figure></p></blockquote><p>可以看出：</p><ul><li>forEach 是没有返回值的，你可以直接修改回调的val值来改变原数组，也可以利用val来生成新数组 <strong>（没有返回值）</strong></li><li>every 是用来做判断，判断数组中的所有元素是否都符合某一个条件吗，符合则返回值是true,具体条件是有回调里面的return的值来决定<strong>（返回布尔值）</strong></li><li>some 是用来做判断，判断数组中的是否存在某一个元素符合某一个条件吗，符合则返回值是true,具体条件是有回调里面的return的值来决定<strong>（返回布尔值）</strong></li><li>filter 是用来过滤，可以过滤出来数组中的某些符合条件的元素集合，具体条件是有回调里面的return的值来决定 <strong>（返回新数组）</strong></li><li>map 是用来根据原数组生成新数组的，元素是回调里面返回的值 <strong>（返回新数组）</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js数组有很多操作方法，其中forEach,every,some,filter,map是常容易混淆用法的，下面我来解释其中的区别&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
      <category term="大前端" scheme="http://blog.inbelieve.top/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://blog.inbelieve.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>js正则表达式之爬虫</title>
    <link href="http://blog.inbelieve.top/frontend/20180617-14.html"/>
    <id>http://blog.inbelieve.top/frontend/20180617-14.html</id>
    <published>2018-06-17T09:27:27.000Z</published>
    <updated>2018-06-17T01:31:44.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过爬虫爬去网页的dom之后就需要用正则来获取相关的信息，下面来说下正则表达式在爬虫中的应用</p><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><blockquote><p>对于Html来说，一般需要匹配的就是相应DOM结构，比如标签属性，内容和数目之类的。</p></blockquote><p>拿一个简单的标签来说比如<code>&lt;span&gt;username&lt;/span&gt;</code>，我们想要拿到<code>username</code>这个内容来用正则实现。<br>这里要先补充一些需要使用的或者比较关键的正则关键词：</p><ul><li>自定义匹配多种字符 - <code>[ ]</code><ul><li>使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。</li><li>用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。</li><li>虽然可以匹配其中任意一个，但是只能是一个，不是多个。</li></ul></li><li>修饰匹配次数 - <code>{}</code>，<code>?</code>，<code>+</code>，<code>*</code><ul><li><strong>{n}</strong> - 表达式重复n次，比如：”/w{2}” 相当于 “/w/w”；”a{5}” 相当于 “aaaaa”</li><li><strong>{m,n}</strong> - 表达式至少重复m次，最多重复n次，比如：”ba{1,3}”可以匹配 “ba”或”baa”或”baaa”</li><li><strong>{m,}</strong> - 表达式至少重复m次，比如：”/w/d{2,}”可以匹配 “a12”,”_456”,”M12344”…</li><li><strong>?</strong> - 匹配表达式0次或者1次，相当于 {0,1}，比如：”a[cd]?”可以匹配 “a”,”ac”,”ad”</li><li><strong>+</strong> - 表达式至少出现1次，相当于 {1,}，比如：”a+b”可以匹配 “ab”,”aab”,”aaab”…</li><li><strong>*</strong> - 表达式不出现或出现任意次，相当于 {0,}，比如：”/^*b”可以匹配 “b”,”^^^b”…</li></ul></li><li>用于group的字符 - <code>()</code><ul><li>在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰</li><li>取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到</li></ul></li><li>用于扩展表达式含义<ul><li><strong>g</strong>：代表可以进行全局匹配</li><li><strong>i</strong>：代表不区分大小写匹配</li><li><strong>m</strong>：代表可以进行多行匹配</li></ul></li></ul><p>上面几个概念就是我们所需要的所有东西了。</p><p>接下里开始匹配span标签并且取出里面的内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;username&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>使用下面的正则即可，其中非贪婪模式很简单的避免了多个相同标签时匹配不正确的问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/&lt;span&gt;(.*?)&lt;\/span&gt;/</span><br></pre></td></tr></table></figure></p><p>如果要取出某些属性的标签比如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span id=&quot;user&quot;&gt;username&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>则可以使用如下正则<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/&lt;span id=&quot;(.*?)&quot;&gt;(.*?)&lt;\/span&gt;/</span><br></pre></td></tr></table></figure></p><p>这样就能够简单快速解决html里面各种标签的数据获取问题</p><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><p>对于匹配出来的数据，如果我们需要全局匹配，可以使用<code>String.match(RegExp)</code>方法。不过该方法只能获取一次的匹配结果，如果需要匹配大段文本中多次的结果就需要使用<code>RegExp.exec(string)</code>方法进行匹配。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var html = &apos;&lt;span id=&quot;sp_1&quot;&gt;a&lt;/span&gt;&lt;span id=&quot;sp_2&quot;&gt;b&lt;/span&gt;&lt;span id=&quot;sp_3&quot;&gt;c&lt;/span&gt;&apos;;</span><br><span class="line">var reg = /&lt;span id=&quot;(.*?)&quot;&gt;(.*?)&lt;\/span&gt;/g;</span><br><span class="line">var result;</span><br><span class="line">while ((result = reg.exec(html)) != null)  &#123;</span><br><span class="line">      console.log(result[1],result[2])</span><br><span class="line">&#125;</span><br><span class="line">//sp_1 a</span><br><span class="line">//sp_2 b</span><br><span class="line">//sp_3 c</span><br></pre></td></tr></table></figure></p><p>这样，对于绝大部分网页内容分析筛选的工作都可以使用简单的正则快速的完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;通过爬虫爬去网页的dom之后就需要用正则来获取相关的信息，下面来说下正则表达式在爬虫中的应用&lt;/p&gt;
&lt;h3 id=&quot;匹配&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="大前端" scheme="http://blog.inbelieve.top/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://blog.inbelieve.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>nodejs之pm2</title>
    <link href="http://blog.inbelieve.top/frontend/20180617-13.html"/>
    <id>http://blog.inbelieve.top/frontend/20180617-13.html</id>
    <published>2018-06-17T09:27:14.000Z</published>
    <updated>2018-06-17T01:31:35.292Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>pm2 是一个带有负载均衡功能的Node应用的进程管理器.当你要把你的独立代码利用全部的服务器上的所有CPU,并保证进程永远都活着,0秒的重载, PM2可以作为完美的守护进程。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure><h4 id="pm2常用命令"><a href="#pm2常用命令" class="headerlink" title="pm2常用命令"></a>pm2常用命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pm2 start app.js              # 启动app.js应用程序</span><br><span class="line"></span><br><span class="line">$ pm2 start app.js -i 4         # cluster mode 模式启动4个app.js的应用实例     # 4个应用程序会自动进行负载均衡</span><br><span class="line"></span><br><span class="line">$ pm2 start app.js --name=&quot;api&quot; # 启动应用程序并命名为 &quot;api&quot;</span><br><span class="line"></span><br><span class="line">$ pm2 start app.js --watch      # 当文件变化时自动重启应用</span><br><span class="line"></span><br><span class="line">$ pm2 start script.sh           # 启动 bash 脚本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ pm2 list                      # 列表 PM2 启动的所有的应用程序</span><br><span class="line"></span><br><span class="line">$ pm2 monit                     # 显示每个应用程序的CPU和内存占用情况</span><br><span class="line"></span><br><span class="line">$ pm2 show [app-name]           # 显示应用程序的所有信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ pm2 logs                      # 显示所有应用程序的日志</span><br><span class="line"></span><br><span class="line">$ pm2 logs [app-name]           # 显示指定应用程序的日志</span><br><span class="line"></span><br><span class="line">$ pm2 flush</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ pm2 stop all                  # 停止所有的应用程序</span><br><span class="line"></span><br><span class="line">$ pm2 stop 0                    # 停止 id为 0的指定应用程序</span><br><span class="line"></span><br><span class="line">$ pm2 restart all               # 重启所有应用</span><br><span class="line"></span><br><span class="line">$ pm2 reload all                # 重启 cluster mode下的所有应用</span><br><span class="line"></span><br><span class="line">$ pm2 gracefulReload all        # Graceful reload all apps in cluster mode</span><br><span class="line"></span><br><span class="line">$ pm2 delete all                # 关闭并删除所有应用</span><br><span class="line"></span><br><span class="line">$ pm2 delete 0                  # 删除指定应用 id 0</span><br><span class="line"></span><br><span class="line">$ pm2 scale api 10              # 把名字叫api的应用扩展到10个实例</span><br><span class="line"></span><br><span class="line">$ pm2 reset [app-name]          # 重置重启数量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ pm2 startup                   # 创建开机自启动命令</span><br><span class="line"></span><br><span class="line">$ pm2 save                      # 保存当前应用列表</span><br><span class="line"></span><br><span class="line">$ pm2 resurrect                 # 重新加载保存的应用列表</span><br><span class="line"></span><br><span class="line">$ pm2 update                    # Save processes, kill PM2 and restore processes</span><br><span class="line"></span><br><span class="line">$ pm2 generate                  # Generate a sample json configuration file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ pm2 deploy app.json prod setup    # Setup &quot;prod&quot; remote server</span><br><span class="line"></span><br><span class="line">$ pm2 deploy app.json prod          # Update &quot;prod&quot; remote server</span><br><span class="line"></span><br><span class="line">$ pm2 deploy app.json prod revert 2 # Revert &quot;prod&quot; remote server by 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ pm2 module:generate [name]    # Generate sample module with name [name]</span><br><span class="line"></span><br><span class="line">$ pm2 install pm2-logrotate     # Install module (here a log rotation system)</span><br><span class="line"></span><br><span class="line">$ pm2 uninstall pm2-logrotate   # Uninstall module</span><br><span class="line"></span><br><span class="line">$ pm2 publish                   # Increment version, git push and npm publish</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;pm2 是一个带有负载均衡功能的Node应用的进程管理器.当你要把你的独立代码利用全部的服务器上的所有CPU,并保证进程永远都活着,0秒的重
      
    
    </summary>
    
      <category term="大前端" scheme="http://blog.inbelieve.top/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://blog.inbelieve.top/tags/javascript/"/>
    
      <category term="NodeJs" scheme="http://blog.inbelieve.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>nodejs之追加内容到文件</title>
    <link href="http://blog.inbelieve.top/frontend/20180617-12.html"/>
    <id>http://blog.inbelieve.top/frontend/20180617-12.html</id>
    <published>2018-06-17T09:27:01.000Z</published>
    <updated>2018-06-17T01:31:26.365Z</updated>
    
    <content type="html"><![CDATA[<p>最近用node跑一个简单服务，需要不停地将请求的内容写日志，所以使用appendFile方法追加内容到文件里面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);  </span><br><span class="line">  </span><br><span class="line">var data = &apos;hello world&apos;;  </span><br><span class="line">fs.appendFile(&apos;./log.txt&apos;,data,&apos;utf8&apos;,function(err)&#123;  </span><br><span class="line">    if(err)  &#123;  </span><br><span class="line">        console.log(err);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近用node跑一个简单服务，需要不停地将请求的内容写日志，所以使用appendFile方法追加内容到文件里面&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="大前端" scheme="http://blog.inbelieve.top/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://blog.inbelieve.top/tags/javascript/"/>
    
      <category term="NodeJs" scheme="http://blog.inbelieve.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中typeof的原理</title>
    <link href="http://blog.inbelieve.top/frontend/20180617-11.html"/>
    <id>http://blog.inbelieve.top/frontend/20180617-11.html</id>
    <published>2018-06-17T09:26:46.000Z</published>
    <updated>2018-06-17T01:31:01.594Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到别人提的一个问题，js中typeof的原理是什么，我只知道<code>typeof null == &#39;object&#39;</code>，但是对于具体原理还真的不清楚，后来找了一下资料，发现如此。</p><blockquote><p>原理是这样的， 不同的对象在底层都表示为二进制， 在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回<code>object</code>。</p></blockquote><p>其实这个是一个历史遗留的bug，在 javascript 的最初版本中，使用的 32 位系统，为了性能考虑使用低位存储了变量的类型信息：</p><ul><li>000：对象</li><li>1：整数</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li></ul><p>有 2 个值比较特殊：</p><ul><li>undefined：用 - （−2^30）表示。</li><li>null：对应机器码的 NULL 指针，一般是全零。</li></ul><p>所以当你使用<code>typeof null</code>时返回就是<code>object</code>了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天遇到别人提的一个问题，js中typeof的原理是什么，我只知道&lt;code&gt;typeof null == &amp;#39;object&amp;#39;&lt;/code&gt;，但是对于具体原理还真的不清楚，后来找了一下资料，发现如此。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原理是这样的， 不
      
    
    </summary>
    
      <category term="大前端" scheme="http://blog.inbelieve.top/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://blog.inbelieve.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript中检查对象是否存在环</title>
    <link href="http://blog.inbelieve.top/frontend/20180617-10.html"/>
    <id>http://blog.inbelieve.top/frontend/20180617-10.html</id>
    <published>2018-06-17T09:26:30.000Z</published>
    <updated>2018-06-17T01:29:47.550Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript中，为了保证代码健壮性，我们需要确认对象中不存在环，现在有2种方法检测js对象是否有环</p><ul><li><p>方法一</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function cycleDetector (obj) &#123;</span><br><span class="line">console.log(arguments)</span><br><span class="line">  // 请添加代码</span><br><span class="line">    let result = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        JSON.stringify(obj);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        result = true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function cycleDetector2(obj) &#123;</span><br><span class="line">    let hasCircle = false,</span><br><span class="line">        cache = [];</span><br><span class="line"></span><br><span class="line">    (function(obj) &#123;</span><br><span class="line">        Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">            const value = obj[key]</span><br><span class="line">            if (typeof value == &apos;object&apos; &amp;&amp; value !== null) &#123;</span><br><span class="line">                const index = cache.indexOf(value)</span><br><span class="line">                if (index !== -1) &#123;</span><br><span class="line">                    hasCircle = true</span><br><span class="line">                    return</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cache.push(value)</span><br><span class="line">                    arguments.callee(value)</span><br><span class="line">                    // (注:箭头函数没有arguments对象，此时的arguments指向该匿名函数的参数)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(obj)</span><br><span class="line"></span><br><span class="line">    return hasCircle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    name: &apos;foo&apos;,</span><br><span class="line">    bar: &#123;</span><br><span class="line">      name: &apos;bar&apos;,</span><br><span class="line">      baz: &#123;</span><br><span class="line">        name: &apos;baz&apos;,</span><br><span class="line">        aChild: null  //待会让它指向obj.foo</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo.bar.baz.aChild = obj.foo</span><br><span class="line">var currentTime = new Date().getTime()</span><br><span class="line">var flag = cycleDetector(obj)</span><br><span class="line">var endTime = new Date().getTime()</span><br><span class="line">var time = endTime - currentTime</span><br><span class="line">console.error(flag, time)</span><br><span class="line"></span><br><span class="line">var currentTime2 = new Date().getTime()</span><br><span class="line">var flag2 = cycleDetector2(obj)</span><br><span class="line">var endTime2 = new Date().getTime()</span><br><span class="line">var time2 = endTime2 - currentTime2</span><br><span class="line">console.error(flag2, time2)</span><br></pre></td></tr></table></figure></p><p>返回结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; &apos;0&apos;: &#123; foo: &#123; name: &apos;foo&apos;, bar: [Object] &#125; &#125; &#125;</span><br><span class="line">true 5</span><br><span class="line">true 0</span><br></pre></td></tr></table></figure></p><p>第一种才用try catch的捕获异常的方法来判断，需要的时间更长，代码更简洁。<br>第二种方法时间更快,但是它执行递归，逻辑较第一种更复杂，空间也需要更大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript中，为了保证代码健壮性，我们需要确认对象中不存在环，现在有2种方法检测js对象是否有环&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法一&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;
      
    
    </summary>
    
      <category term="大前端" scheme="http://blog.inbelieve.top/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://blog.inbelieve.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置允许跨域</title>
    <link href="http://blog.inbelieve.top/server/20180617-9.html"/>
    <id>http://blog.inbelieve.top/server/20180617-9.html</id>
    <published>2018-06-17T09:23:06.000Z</published>
    <updated>2018-06-17T01:25:13.896Z</updated>
    
    <content type="html"><![CDATA[<p>nginx设置允许跨域<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; #设置允许跨域</span><br><span class="line">add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; #设置跨域是否需要认证(此处可不需要)</span><br><span class="line">add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; #设置允许通过跨域方法</span><br><span class="line">add_header &apos;Access-Control-Allow-Headers&apos; &apos;X-Requested-With&apos;; #设置允许跨域的header</span><br></pre></td></tr></table></figure></p><p>这一段可以放在http、server、location里面分别代表不同程度的跨域，其中Access-Control-Allow-Headers，Access-Control-Allow-Credentials可以不设置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx设置允许跨域&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;add_header &amp;apos;Access-Control-Allow-
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Web服务器" scheme="http://blog.inbelieve.top/tags/webserver/"/>
    
      <category term="Nginx" scheme="http://blog.inbelieve.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx之upstream负载均衡</title>
    <link href="http://blog.inbelieve.top/server/20180617-8.html"/>
    <id>http://blog.inbelieve.top/server/20180617-8.html</id>
    <published>2018-06-17T09:22:50.000Z</published>
    <updated>2018-06-17T01:25:03.651Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h5 id="1-准备三台机器"><a href="#1-准备三台机器" class="headerlink" title="1. 准备三台机器"></a>1. 准备三台机器</h5>192.168.2.151        web服务器<br>192.168.2.152        web服务器<br>192.168.2.150        负载均衡服务器</li><li><h5 id="2-三台机器都配置-其中151-152作为web服务器，150作为负载均衡"><a href="#2-三台机器都配置-其中151-152作为web服务器，150作为负载均衡" class="headerlink" title="2. 三台机器都配置,其中151,152作为web服务器，150作为负载均衡"></a>2. 三台机器都配置,其中151,152作为web服务器，150作为负载均衡</h5></li></ul><p>ubuntu/debian<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update -y</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure></p><p>centos<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install nginx -y</span><br></pre></td></tr></table></figure></p><p>安装成功后启动nginx</p><ul><li><h5 id="3-配置负载均衡服务器："><a href="#3-配置负载均衡服务器：" class="headerlink" title="3 配置负载均衡服务器："></a>3 配置负载均衡服务器：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li></ul><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user  www-data;  </span><br><span class="line">worker_processes  1;  </span><br><span class="line">  </span><br><span class="line">error_log  /var/log/nginx/error.log warn;  </span><br><span class="line">pid        /var/run/nginx.pid;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">events &#123;  </span><br><span class="line">    worker_connections  1024;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">http &#123;  </span><br><span class="line">    include       /etc/nginx/mime.types;  </span><br><span class="line">    default_type  application/octet-stream;  </span><br><span class="line">  </span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;  </span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;  </span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;  </span><br><span class="line">  </span><br><span class="line">    access_log  /var/log/nginx/access.log  main;  </span><br><span class="line">  </span><br><span class="line">    sendfile        on;  </span><br><span class="line">    #tcp_nopush     on;  </span><br><span class="line">  </span><br><span class="line">    keepalive_timeout  65;  </span><br><span class="line">  </span><br><span class="line">    #gzip  on;  </span><br><span class="line">    upstream your.website.name &#123;  </span><br><span class="line">          server 192.168.2.151:80;  </span><br><span class="line">          server 192.168.2.152:80;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">  </span><br><span class="line">    server &#123;     </span><br><span class="line">        listen       80;</span><br><span class="line">        server_name your.website.name;       </span><br><span class="line">        charset utf-8;     </span><br><span class="line">        location / &#123;        </span><br><span class="line">            proxy_pass        http://your.website.name;     </span><br><span class="line">            proxy_set_header  X-Real-IP  $remote_addr;     </span><br><span class="line">            client_max_body_size  100m;  </span><br><span class="line">        &#125;     </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        location ~ ^/(WEB-INF)/ &#123;      </span><br><span class="line">               deny all;      </span><br><span class="line">        &#125;      </span><br><span class="line">    </span><br><span class="line">        error_page   500 502 503 504  /50x.html;     </span><br><span class="line">        location = /50x.html &#123;     </span><br><span class="line">            root   /var/www/html/;     </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>浏览器打开192.168.2.150，如果151、152交替显示则表明试验成功。</p><ul><li><h5 id="4-其他的功能扩展"><a href="#4-其他的功能扩展" class="headerlink" title="4. 其他的功能扩展"></a>4. 其他的功能扩展</h5>(1)、轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream your.website.name &#123;  </span><br><span class="line">      server 192.168.2.151:80;  </span><br><span class="line">      server 192.168.2.152:80;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>(2)、weight<br>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream your.website.name &#123;</span><br><span class="line">     server 192.168.2.151 weight=5 max_fails=3 fail_timeout=20s;;</span><br><span class="line">     server 192.168.2.152 weight=10 max_fails=3 fail_timeout=20s;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(3)、ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream your.website.name &#123;</span><br><span class="line">     ip_hash;</span><br><span class="line">     server 192.168.2.151:80;</span><br><span class="line">     server 192.168.2.152:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(4)、fair（需要安装第三方库upstream-fair支持）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream your.website.name &#123;</span><br><span class="line">     server 192.168.2.151:80;</span><br><span class="line">     server 192.168.2.152:80;</span><br><span class="line">     fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(5)、url_hash（需要安装第三方库Nginx_upstream_hash支持）</p><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。<br>例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream your.website.name &#123;</span><br><span class="line">     server 192.168.2.151:80;</span><br><span class="line">     server 192.168.2.152:80;</span><br><span class="line">      hash $request_uri;</span><br><span class="line">      hash_method crc32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(6)、建议<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream your.website.name&#123; #定义负载均衡设备的Ip及设备状态</span><br><span class="line">      ip_hash;</span><br><span class="line">      server 127.0.0.1:8000 down;</span><br><span class="line">      server 127.0.0.1:8080 weight=2;</span><br><span class="line">      server 127.0.0.1:6801;</span><br><span class="line">      server 127.0.0.1:6802 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释：<br>1.down 表示单前的server暂时不参与负载<br>2.weight 默认为1.weight越大，负载的权重就越大。<br>3.max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误<br>4.fail_timeout:max_fails次失败后，暂停的时间。<br>5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</p><ul><li><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4>实际上，我们可以部署时，设置服务器作为backup备份，设置服务器暂时不开启(down),必要活动时在开启，跟进服务器的不同配置设置不同的比重(weight),还可以设置默认同一个ip自动进同一个服务器，这样保证session的一致性。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h5 id=&quot;1-准备三台机器&quot;&gt;&lt;a href=&quot;#1-准备三台机器&quot; class=&quot;headerlink&quot; title=&quot;1. 准备三台机器&quot;&gt;&lt;/a&gt;1. 准备三台机器&lt;/h5&gt;192.168.2.151        web服务器&lt;br&gt;192.168
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Web服务器" scheme="http://blog.inbelieve.top/tags/webserver/"/>
    
      <category term="Nginx" scheme="http://blog.inbelieve.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx之alias与root</title>
    <link href="http://blog.inbelieve.top/server/20180617-7.html"/>
    <id>http://blog.inbelieve.top/server/20180617-7.html</id>
    <published>2018-06-17T09:22:34.000Z</published>
    <updated>2018-06-17T01:24:52.365Z</updated>
    
    <content type="html"><![CDATA[<p> Nginx的location块中的root用法，大家应该都知道，就是用来映射路径用的，而alias也是用来映射路径用的，n那么这2者有什么区别呢？</p><h4 id="先看root的用法"><a href="#先看root的用法" class="headerlink" title="先看root的用法"></a>先看root的用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /request_path/image/ &#123;</span><br><span class="line">    root /local_path/image/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端请求 /request_path/image/123.jpg的时候，<br>实际上是映射的/local_path/image/request_path/image/123.jpg;</p><h4 id="alias的用法"><a href="#alias的用法" class="headerlink" title="alias的用法"></a>alias的用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /request_path/image/ &#123;</span><br><span class="line">    alias /local_path/image/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端请求 /request_path/image/123.png 的时候，<br>Nginx把请求映射为/local_path/image/123.png </p><p>总结，root和alias都可以用来映射路径，root后面跟的时候之后的真实路径，alias则可以用来显示真实路径，也可以用来重写路径，一般我们在location / 里面使用root,而在location /other/ 里面使用alias。</p><blockquote><p>大家可以去配置试一下，有什么不对的，请指正。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; Nginx的location块中的root用法，大家应该都知道，就是用来映射路径用的，而alias也是用来映射路径用的，n那么这2者有什么区别呢？&lt;/p&gt;
&lt;h4 id=&quot;先看root的用法&quot;&gt;&lt;a href=&quot;#先看root的用法&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Web服务器" scheme="http://blog.inbelieve.top/tags/webserver/"/>
    
      <category term="Nginx" scheme="http://blog.inbelieve.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>服务器之负载均衡</title>
    <link href="http://blog.inbelieve.top/server/20180617-6.html"/>
    <id>http://blog.inbelieve.top/server/20180617-6.html</id>
    <published>2018-06-17T09:22:07.000Z</published>
    <updated>2018-06-27T13:17:15.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>所谓负载均衡，就是将任务分摊到多个操作单元上进行执行，因为多台服务器的承载能力各不相同，这可能体现在硬件配置、网络带宽的差异，也可能因为某台服务器身兼多职，我们所说的“均衡”，也就是希望所有服务器都不要过载，并且能够最大程度地发挥作用。下面谈谈目前流行的几种web负载均衡的策略。</p><h3 id="一、HTTP重定向"><a href="#一、HTTP重定向" class="headerlink" title="一、HTTP重定向"></a>一、HTTP重定向</h3><p>当用户发来请求的时候，Web服务器通过修改HTTP响应头中的Location标记来返回一个新的url，然后浏览器再继续请求这个新url，实际上就是页面重定向。通过重定向，来达到“负载均衡”的目标。例如，我们在下载PHP源码包的时候，点击下载链接时，为了解决不同国家和地域下载速度的问题，它会返回一个离我们近的下载地址。重定向的HTTP返回码是302。重定向非常容易实现，并且可以自定义各种策略。但是，它在大规模访问量下，性能不佳。而且，给用户的体验也不好，实际请求发生重定向，增加了网络延时。</p><h4 id="性能缺陷："><a href="#性能缺陷：" class="headerlink" title="性能缺陷："></a>性能缺陷：</h4><ul><li><p>吞吐率限制<br>主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs/s，那么主服务器的吞吐率要达到3000reqs/s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs/s，那么平均分配到子服务器的吞吐率为2000reqs/s，而现子服务器的最大吞吐率为1000reqs/s，因此就得增加子服务器的数量，增加到6个才能满足。</p></li><li><p>重定向访问深度不同<br>有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。</p></li></ul><p>我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。</p><h3 id="二、反向代理负载均衡"><a href="#二、反向代理负载均衡" class="headerlink" title="二、反向代理负载均衡"></a>二、反向代理负载均衡</h3><p>反向代理服务的核心工作主要是转发HTTP请求，扮演了浏览器端和后台Web服务器中转的角色。因为它工作在HTTP层（应用层），也就是网络七层结构中的第七层，因此也被称为“七层负载均衡”。可以做反向代理的软件很多，比较常见的一种是Nginx。</p><p>Nginx是一种非常灵活的反向代理软件，可以自由定制化转发策略，分配服务器流量的权重等。反向代理中，常见的一个问题，就是Web服务器存储的session数据，因为一般负载均衡的策略都是随机分配请求的。同一个登录用户的请求，无法保证一定分配到相同的Web机器上，会导致无法找到session的问题。</p><p>解决方案主要有两种：</p><ul><li>配置反向代理的转发规则，让同一个用户的请求一定落到同一台机器上（通过分析cookie），复杂的转发规则将会消耗更多的CPU，也增加了代理服务器的负担。</li><li>将session这类的信息，专门用某个独立服务来存储，例如redis/memchache，这个方案是比较推荐的。<br>反向代理服务，也是可以开启缓存的，如果开启了，会增加反向代理的负担，需要谨慎使用。这种负载均衡策略实现和部署非常简单，而且性能表现也比较好。但是，它有“单点故障”的问题，如果挂了，会带来很多的麻烦。而且，到了后期Web服务器继续增加，它本身可能成为系统的瓶颈。</li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。</p><p>对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。</p><p>反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。</p><p>反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。<br>反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。</p><h3 id="三、IP负载均衡-LVS-NAT"><a href="#三、IP负载均衡-LVS-NAT" class="headerlink" title="三、IP负载均衡(LVS-NAT)"></a>三、IP负载均衡(LVS-NAT)</h3><p>因为反向代理服务器工作在HTTP层，其本身的开销就已经严重制约了可扩展性，从而也限制了它的性能极限。那能否在HTTP层面以下实现负载均衡呢？答案当然是能。IP负载均衡服务是工作在网络层（修改IP）和传输层（修改端口，第四层），比起工作在应用层（第七层）性能要高出非常多。原理是，他是对IP层的数据包的IP地址和端口信息进行修改，达到负载均衡的目的。这种方式，也被称为“四层负载均衡”。常见的负载均衡方式，是LVS（Linux Virtual Server，Linux虚拟服务），通过IPVS（IP Virtual Server，IP虚拟服务）来实现。</p><p>在负载均衡服务器收到客户端的IP包的时候，会修改IP包的目标IP地址或端口，然后原封不动地投递到内部网络中，数据包会流入到实际Web服务器。实际服务器处理完成后，又会将数据包投递回给负载均衡服务器，它再修改目标IP地址为用户IP地址，最终回到客户端。</p><p>上述的方式叫LVS-NAT，除此之外，还有LVS-DR（直接路由），LVS-TUN（IP隧道），三者之间都属于LVS的方式，但是有一定的区别。</p><p>IP负载均衡的性能要高出Nginx的反向代理很多，它只处理到传输层为止的数据包，并不做进一步的组包，然后直接转发给实际服务器。不过，它的配置和搭建比较复杂。</p><p>实验证明使用基于NAT的负载均衡系统，作为调度器的NAT服务器可以将吞吐率提升到一个新的高度，几乎是反向代理服务器的两倍以上，这大多归功于在内核中进行请求转发的较低开销。但是一旦请求的内容过大时，不论是基于反向代理还是NAT，负载均衡的整体吞吐量都差距不大，这说明对于一睦开销较大的内容，使用简单的反向代理来搭建负载均衡系统是值考虑的。</p><p>这么强大的系统还是有它的瓶颈，那就是NAT服务器的网络带宽，包括内部网络和外部网络。当然如果你不差钱，可以去花钱去购买千兆交换机或万兆交换机，甚至负载均衡硬件设备，但如果你是个屌丝，咋办？</p><p>一个简单有效的办法就是将基于NAT的集群和前面的DNS混合使用，比如５个100Mbps出口宽带的集群，然后通过DNS来将用户请求均衡地指向这些集群，同时，你还可以利用DNS智能解析实现地域就近访问。这样的配置对于大多数业务是足够了，但是对于提供下载或视频等服务的大规模站点，NAT服务器还是不够出色。</p><h3 id="四、直接路由-LVS-DR"><a href="#四、直接路由-LVS-DR" class="headerlink" title="四、直接路由(LVS-DR)"></a>四、直接路由(LVS-DR)</h3><p>NAT是工作在网络分层模型的传输层（第四层），而直接路由是工作在数据链路层（第二层），貌似更屌些。它通过修改数据包的目标MAC地址（没有修改目标IP），将数据包转发到实际服务器上，不同的是，实际服务器的响应数据包将直接发送给客户羰，而不经过调度器。</p><p>LVS-DR 相较于LVS-NAT的最大优势在于LVS-DR不受调度器宽带的限制，例如假设三台服务器在WAN交换机出口宽带都限制为10Mbps，只要对于连接调度器和两台实际服务器的LAN交换机没有限速，那么，使用LVS-DR理论上可以达到20Mbps的最大出口宽带，因为它的实际服务器的响应数据包可以不经过调度器而直接发往用户端啊，所以它与调度器的出口宽带没有关系，只能自身的有关系。而如果使用LVS-NAT，集群只能最大使用10Mbps的宽带。所以，越是响应数据包远远超过请求数据包的服务，就越应该降低调度器转移请求的开销，也就越能提高整体的扩展能力，最终也就越依赖于WAN出口宽带。</p><p>总的来说，LVS-DR适合搭建可扩展的负载均衡系统，不论是Web服务器还是文件服务器，以及视频服务器，它都拥有出色的性能。前提是你必须为实际器购买一系列的合法IP地址。</p><h3 id="五、IP隧道-LVS-TUN"><a href="#五、IP隧道-LVS-TUN" class="headerlink" title="五、IP隧道(LVS-TUN)"></a>五、IP隧道(LVS-TUN)</h3><p>基于IP隧道的请求转发机制：将调度器收到的IP数据包封装在一个新的IP数据包中，转交给实际服务器，然后实际服务器的响应数据包可以直接到达用户端。目前Linux大多支持，可以用LVS来实现，称为LVS-TUN，与LVS-DR不同的是，实际服务器可以和调度器不在同一个WANt网段，调度器通过 IP隧道技术来转发请求到实际服务器，所以实际服务器也必须拥有合法的IP地址。</p><p>总体来说，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可以将实际服务器根据需要部署在不同的地域，并且根据就近访问的原则来转移请求，所以有类似这种需求的，就应该选择LVS-TUN。</p><h3 id="六、DNS负载均衡"><a href="#六、DNS负载均衡" class="headerlink" title="六、DNS负载均衡"></a>六、DNS负载均衡</h3><p>DNS（Domain Name System）负责域名解析的服务，域名url实际上是服务器的别名，实际映射是一个IP地址，解析过程，就是DNS完成域名到IP的映射。而一个域名是可以配置成对应多个IP的。因此，DNS也就可以作为负载均衡服务。</p><p>这种负载均衡策略，配置简单，性能极佳。但是，不能自由定义规则，而且，变更被映射的IP或者机器故障时很麻烦，还存在DNS生效延迟的问题。</p><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><p>可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。</p><p>动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。</p><h3 id="七、DNS-GSLB负载均衡"><a href="#七、DNS-GSLB负载均衡" class="headerlink" title="七、DNS/GSLB负载均衡"></a>七、DNS/GSLB负载均衡</h3><p>我们常用的CDN（Content Delivery Network，内容分发网络）实现方式，其实就是在同一个域名映射为多IP的基础上更进一步，通过GSLB（Global Server Load Balance，全局负载均衡）按照指定规则映射域名的IP。一般情况下都是按照地理位置，将离用户近的IP返回给用户，减少网络传输中的路由节点之间的跳跃消耗。</p><p>CDN在Web系统中，一般情况下是用来解决大小较大的静态资源（html/Js/Css/图片等）的加载问题，让这些比较依赖网络下载的内容，尽可能离用户更近，提升用户体验。</p><p>这种方式，和前面的DNS负载均衡一样，不仅性能极佳，而且支持配置多种策略。但是，搭建和维护成本非常高。互联网一线公司，会自建CDN服务，中小型公司一般使用第三方提供的CDN。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://developer.51cto.com/art/201410/454951.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201410/454951.htm</a><br><a href="http://blog.jobbole.com/91738/" target="_blank" rel="noopener">http://blog.jobbole.com/91738/</a><br><a href="http://www.open-open.com/lib/view/open1416924842581.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1416924842581.html</a><br><a href="http://voidy.net/web_load_balance" target="_blank" rel="noopener">http://voidy.net/web_load_balance</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h2&gt;&lt;p&gt;所谓负载均衡，就是将任务分摊到多个操作单元上进行执行，因为多台服务器的承载能力各不相同，这可能体现在硬件配置、网络带宽的差异
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Web服务器" scheme="http://blog.inbelieve.top/tags/webserver/"/>
    
  </entry>
  
  <entry>
    <title>Nginx中巧用return来测试</title>
    <link href="http://blog.inbelieve.top/server/20180617-5.html"/>
    <id>http://blog.inbelieve.top/server/20180617-5.html</id>
    <published>2018-06-17T09:20:35.000Z</published>
    <updated>2018-06-17T01:24:25.156Z</updated>
    
    <content type="html"><![CDATA[<p>最近用到一个项目部署到服务器上，发现在nginx上配置proxy_pass之后请求参数丢失了，查询了很久一直没找到原因，后来使用nginx中return，把参数打印出来，这样成功解决了问题。</p><ul><li>返回状态码</li></ul><p>nginx 配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location = /test &#123;</span><br><span class="line">      return 403 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过返回的页面为： 403 Forbidden 正常的403错误返回码报错</p><ul><li><p>返回 文本信息和json</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ^~ /pic &#123;</span><br><span class="line">    default_type text/html ;</span><br><span class="line">    return 200  &apos;hello world! &apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /pic &#123;</span><br><span class="line">    default_type application/json ;</span><br><span class="line">    return 200  &apos;&#123;&quot;name&quot;:&quot;nanjing_wuxu&quot;,&quot;result&quot;:&quot;success&quot;&#125;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接跳转功能</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ^~ /pic &#123;</span><br><span class="line">     return http://192.168.1.19/test.jpg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接返回$queryString, $document_root $fastcgi_path_info</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ^~ /pic &#123;location ~ \.php(.*)$ &#123;</span><br><span class="line">     default_type text/html ;</span><br><span class="line">    return 200  $document_root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /pic &#123;location ~ \.php(.*)$ &#123;</span><br><span class="line">     default_type text/html ;</span><br><span class="line">    return 200  $fastcgi_path_info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /pic &#123;location ~ \.php(.*)$ &#123;</span><br><span class="line">     default_type text/html ;</span><br><span class="line">    return 200  $queryString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上你可以通过nginx的return功能来做确认转发之前是否已经把所有信息都转发了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近用到一个项目部署到服务器上，发现在nginx上配置proxy_pass之后请求参数丢失了，查询了很久一直没找到原因，后来使用nginx中return，把参数打印出来，这样成功解决了问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回状态码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;nginx 配置
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Web服务器" scheme="http://blog.inbelieve.top/tags/webserver/"/>
    
      <category term="Nginx" scheme="http://blog.inbelieve.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>比较Cookie Session localStorage sessionStorage之区别</title>
    <link href="http://blog.inbelieve.top/frontend/20180617-4.html"/>
    <id>http://blog.inbelieve.top/frontend/20180617-4.html</id>
    <published>2018-06-17T09:13:42.000Z</published>
    <updated>2018-06-17T01:19:32.332Z</updated>
    
    <content type="html"><![CDATA[<p>今天在做Vue的项目时，遇到一个关于存储数据<code>list</code>的问题，最初打算是放在Vuex中，但发现一旦刷新页面就消失了，必须重新请求。于是，我又想了下把<code>list</code>存储在cookie里，发现cookie又有大小限制，而放在localStorage中又会一直存在，必须手动清除，最后选择了sessionStorage中。发现原来还有这样的几种不同的方式，这里就对现有的cookie,session,localstorage,sessionstorage进行分析下：</p><h4 id="cookie和session都是用来跟踪浏览器用户身份的会话方式。区别："><a href="#cookie和session都是用来跟踪浏览器用户身份的会话方式。区别：" class="headerlink" title="cookie和session都是用来跟踪浏览器用户身份的会话方式。区别："></a>cookie和session都是用来跟踪浏览器用户身份的会话方式。区别：</h4><p>1、保持状态：</p><ul><li>cookie保存在浏览器端</li><li>session保存在服务器端</li></ul><p>2、使用方式：</p><ul><li>cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它</span><br></pre></td></tr></table></figure><ul><li>session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。</li></ul><p>3、存储内容：</p><ul><li>cookie只能保存字符串类型，以文本的方式</li><li>session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)</li></ul><p>4、存储的大小：</p><ul><li>cookie：单个cookie保存的数据不能超过4kb；</li><li>session大小没有限制。</li></ul><p>5、安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。原因如下：</p><ul><li>sessionID存储在cookie中，若要攻破session首先要攻破cookie；</li><li>sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；</li><li>第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。</li><li><p>sessionID是加密的</p><p>6、缺点：</p></li><li><p>cookie：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 大小受限</span><br><span class="line">- 用户可以操作（禁用）cookie，使功能受限</span><br><span class="line">- 安全性较低</span><br><span class="line">- 有些状态不可能保存在客户端。</span><br><span class="line">- 每次访问都要传送cookie给服务器，浪费带宽。</span><br><span class="line">- cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。</span><br></pre></td></tr></table></figure></li><li><p>session：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</span><br><span class="line">- 依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全</span><br></pre></td></tr></table></figure></li></ul><h4 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h4><p>WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。</p><p>WebStorage两个主要目标：</p><ul><li>提供一种在cookie之外存储会话数据的路径。</li><li>提供一种存储大量可以跨会话存在的数据的机制。</li></ul><p>HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage(会话存储）,以下从各个方面来比较区别</p><h5 id="1、生命周期："><a href="#1、生命周期：" class="headerlink" title="1、生命周期："></a>1、生命周期：</h5><ul><li><p>localStorage:<br>  localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。</p></li><li><p>sessionStorage<br>  sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。</p></li></ul><h5 id="2、存储大小："><a href="#2、存储大小：" class="headerlink" title="2、存储大小："></a>2、存储大小：</h5><p>localStorage和sessionStorage的存储数据大小一般都是：5MB</p><h5 id="3、存储位置："><a href="#3、存储位置：" class="headerlink" title="3、存储位置："></a>3、存储位置：</h5><p>localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。</p><h5 id="4、存储内容类型："><a href="#4、存储内容类型：" class="headerlink" title="4、存储内容类型："></a>4、存储内容类型：</h5><p>localStorage和sessionStorage只能存储字符串类型</p><h5 id="5、获取方式："><a href="#5、获取方式：" class="headerlink" title="5、获取方式："></a>5、获取方式：</h5><ul><li>localStorage：window.localStorage</li><li>sessionStorage：window.sessionStorage</li></ul><h5 id="6、应用场景："><a href="#6、应用场景：" class="headerlink" title="6、应用场景："></a>6、应用场景：</h5><ul><li>localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。-<br>sessionStorage：敏感账号一次性登录；</li></ul><h4 id="WebStorage的优点："><a href="#WebStorage的优点：" class="headerlink" title="WebStorage的优点："></a>WebStorage的优点：</h4><ul><li><p>存储空间更大：cookie为4KB，而WebStorage是5MB；</p></li><li><p>节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；</p></li><li><p>对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；</p></li><li><p>快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；</p></li><li><p>安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；</p></li><li><p>WebStorage提供了一些方法，数据操作比cookie方便；</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setItem (key, value) ——  保存数据，以键值对的方式储存信息。</span><br><span class="line">getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。</span><br><span class="line">removeItem (key) ——  删除单个数据，根据键值移除对应的信息。</span><br><span class="line">clear () ——  删除所有的数据</span><br><span class="line">key (index) —— 获取某个索引的key</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在做Vue的项目时，遇到一个关于存储数据&lt;code&gt;list&lt;/code&gt;的问题，最初打算是放在Vuex中，但发现一旦刷新页面就消失了，必须重新请求。于是，我又想了下把&lt;code&gt;list&lt;/code&gt;存储在cookie里，发现cookie又有大小限制，而放在local
      
    
    </summary>
    
      <category term="大前端" scheme="http://blog.inbelieve.top/categories/frontend/"/>
    
    
      <category term="JavaScript" scheme="http://blog.inbelieve.top/tags/javascript/"/>
    
      <category term="HTML5" scheme="http://blog.inbelieve.top/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>mysql之慢查询</title>
    <link href="http://blog.inbelieve.top/server/20180617-3.html"/>
    <id>http://blog.inbelieve.top/server/20180617-3.html</id>
    <published>2018-06-17T09:13:08.000Z</published>
    <updated>2018-06-17T01:17:08.918Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定位慢查询sql语句"><a href="#定位慢查询sql语句" class="headerlink" title="定位慢查询sql语句"></a>定位慢查询sql语句</h4><p>可以通过开启慢查询来将所有的慢查询记录到某个文件里面，这里以slow-query.log为例</p><h6 id="方式一-通过工具分析"><a href="#方式一-通过工具分析" class="headerlink" title="方式一:通过工具分析"></a>方式一:通过工具分析</h6><p>MySQL自带了mysqldumpslow工具用来分析slow query日志，除此之外，还有一些好用的开源工具。比如MyProfi、mysql-log-filter，当然还有mysqlsla等</p><p>以下是mysqldumpslow常用参数说明，详细的可应用mysqldumpslow -help查询。</p><ul><li>-s，是表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序（从大到小），ac、at、al、ar表示相应的倒叙。 </li><li>-t，是top n的意思，即为返回前面多少条数据。</li><li>-g，后边可以写一个正则匹配模式，大小写不敏感。</li></ul><p>接下来就是用mysql自带的慢查询工具mysqldumpslow分析了（mysql的bin目录下），我这里的日志文件名字是slow-query.log。</p><p>列出记录次数最多的10个sql语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s c -t 10 slow-query.log</span><br></pre></td></tr></table></figure></p><p>列出返回记录集最多的10个sql语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 slow-query.log</span><br></pre></td></tr></table></figure></p><p>按照时间返回前10条里面含有左连接的sql语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; slow-query.log</span><br></pre></td></tr></table></figure></p><p>使用mysqldumpslow命令可以非常明确的得到各种我们需要的查询语句，对MySQL查询语句的监控、分析、优化起到非常大的帮助。</p><h6 id="方式二-直接分析mysql慢查询日志"><a href="#方式二-直接分析mysql慢查询日志" class="headerlink" title="方式二:直接分析mysql慢查询日志"></a>方式二:直接分析mysql慢查询日志</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time                 Id Command    Argument</span><br><span class="line"># Time: 180419 10:17:15</span><br><span class="line"># User@Host: root[root] @ localhost [::1]</span><br><span class="line"># Thread_id: 2  Schema:   QC_hit: No</span><br><span class="line"># Query_time: 3.018396  Lock_time: 0.000000  Rows_sent: 1  Rows_examined: 0</span><br><span class="line"># Rows_affected: 0</span><br><span class="line">SET timestamp=1524104235;</span><br><span class="line">SELECT `h_room_item`.`id`, `h_room_item`.`num`, `h_room_item`.`code`, `h_order`.`ord_no`, `h_order`.`stat`, `h_order`.`sex`, `h_order`.`end_dat`, `h_order`.`start_dat`, `h_item_flag`.`flag_id` FROM `h_room_item` LEFT JOIN `h_item_flag` ON h_item_flag.room_id=h_room_item.id LEFT JOIN `h_order` ON h_order.room_no=h_room_item.num and h_order.code=h_room_item.code WHERE (`h_room_item`.`code`=&apos;qt001&apos;) AND (`h_item_flag`.`flag_id` IN (&apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;9&apos;, &apos;17&apos;, &apos;18&apos;, &apos;19&apos;, &apos;20&apos;, &apos;21&apos;))  ORDER BY `h_room_item`.`id` LIMIT 24;</span><br></pre></td></tr></table></figure><p>使用desc或者explain来分析sql语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc SELECT `h_room_item`.`id`, `h_room_item`.`num`, `h_room_item`.`code`, </span><br><span class="line">`h_order`.`ord_no`, `h_order`.`stat`, `h_order`.`sex`, `h_order`.`end_dat`, </span><br><span class="line">`h_order`.`start_dat`, `h_item_flag`.`flag_id` FROM `h_room_item` LEFT JOIN </span><br><span class="line">`h_item_flag` ON h_item_flag.room_id=h_room_item.id LEFT JOIN `h_order` ON </span><br><span class="line">h_order.room_no=h_room_item.num and h_order.code=h_room_item.code WHERE </span><br><span class="line">(`h_room_item`.`code`=&apos;qt001&apos;) AND (`h_item_flag`.`flag_id` IN (&apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;9&apos;, &apos;17&apos;, &apos;18&apos;, </span><br><span class="line">&apos;19&apos;, &apos;20&apos;, &apos;21&apos;))  ORDER BY `h_room_item`.`id` LIMIT 24\G;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: h_item_flag</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 28</span><br><span class="line">        Extra: Using where; Using temporary; Using filesort</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: h_room_item</span><br><span class="line">         type: eq_ref</span><br><span class="line">possible_keys: PRIMARY,index2</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: hotel_door.h_item_flag.room_id</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using where</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: h_order</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: index3</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 10</span><br><span class="line">        Extra: Using where; Using join buffer (flat, BNL join)</span><br><span class="line">3 rows in set (0.60 sec)</span><br></pre></td></tr></table></figure><h4 id="可能原因："><a href="#可能原因：" class="headerlink" title="可能原因："></a>可能原因：</h4><ul><li>1、没有索引或者没有用到索引(这是查询慢最常见的问题，是程序设计的缺陷)</li><li>2、I/O吞吐量小，形成了瓶颈效应。</li><li>3、没有创建计算列导致查询不优化。</li><li>4、内存不足</li><li>5、网络速度慢</li><li>6、查询出的数据量过大(可以采用多次查询，其他的方法降低数据量)</li><li>7、锁或者死锁(这也是查询慢最常见的问题，是程序设计的缺陷)</li><li>8、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。</li><li>9、返回了不必要的行和列</li><li>10、查询语句不好，没有优化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;定位慢查询sql语句&quot;&gt;&lt;a href=&quot;#定位慢查询sql语句&quot; class=&quot;headerlink&quot; title=&quot;定位慢查询sql语句&quot;&gt;&lt;/a&gt;定位慢查询sql语句&lt;/h4&gt;&lt;p&gt;可以通过开启慢查询来将所有的慢查询记录到某个文件里面，这里以slow-que
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="MySQL" scheme="http://blog.inbelieve.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>慢查询原因总结</title>
    <link href="http://blog.inbelieve.top/skill/20180617-1.html"/>
    <id>http://blog.inbelieve.top/skill/20180617-1.html</id>
    <published>2018-06-17T09:10:38.000Z</published>
    <updated>2018-06-17T01:12:10.094Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定位慢查询sql语句"><a href="#定位慢查询sql语句" class="headerlink" title="定位慢查询sql语句"></a>定位慢查询sql语句</h4><p>可以通过开启慢查询来将所有的慢查询记录到某个文件里面，这里以slow-query.log为例</p><h6 id="方式一-通过工具分析"><a href="#方式一-通过工具分析" class="headerlink" title="方式一:通过工具分析"></a>方式一:通过工具分析</h6><p>MySQL自带了mysqldumpslow工具用来分析slow query日志，除此之外，还有一些好用的开源工具。比如MyProfi、mysql-log-filter，当然还有mysqlsla等</p><p>以下是mysqldumpslow常用参数说明，详细的可应用mysqldumpslow -help查询。</p><ul><li>-s，是表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序（从大到小），ac、at、al、ar表示相应的倒叙。 </li><li>-t，是top n的意思，即为返回前面多少条数据。</li><li>-g，后边可以写一个正则匹配模式，大小写不敏感。</li></ul><p>接下来就是用mysql自带的慢查询工具mysqldumpslow分析了（mysql的bin目录下），我这里的日志文件名字是slow-query.log。</p><p>列出记录次数最多的10个sql语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s c -t 10 slow-query.log</span><br></pre></td></tr></table></figure></p><p>列出返回记录集最多的10个sql语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 slow-query.log</span><br></pre></td></tr></table></figure></p><p>按照时间返回前10条里面含有左连接的sql语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; slow-query.log</span><br></pre></td></tr></table></figure></p><p>使用mysqldumpslow命令可以非常明确的得到各种我们需要的查询语句，对MySQL查询语句的监控、分析、优化起到非常大的帮助。</p><h6 id="方式二-直接分析mysql慢查询日志"><a href="#方式二-直接分析mysql慢查询日志" class="headerlink" title="方式二:直接分析mysql慢查询日志"></a>方式二:直接分析mysql慢查询日志</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time                 Id Command    Argument</span><br><span class="line"># Time: 180419 10:17:15</span><br><span class="line"># User@Host: root[root] @ localhost [::1]</span><br><span class="line"># Thread_id: 2  Schema:   QC_hit: No</span><br><span class="line"># Query_time: 3.018396  Lock_time: 0.000000  Rows_sent: 1  Rows_examined: 0</span><br><span class="line"># Rows_affected: 0</span><br><span class="line">SET timestamp=1524104235;</span><br><span class="line">SELECT `h_room_item`.`id`, `h_room_item`.`num`, `h_room_item`.`code`, `h_order`.`ord_no`, `h_order`.`stat`, `h_order`.`sex`, `h_order`.`end_dat`, `h_order`.`start_dat`, `h_item_flag`.`flag_id` FROM `h_room_item` LEFT JOIN `h_item_flag` ON h_item_flag.room_id=h_room_item.id LEFT JOIN `h_order` ON h_order.room_no=h_room_item.num and h_order.code=h_room_item.code WHERE (`h_room_item`.`code`=&apos;qt001&apos;) AND (`h_item_flag`.`flag_id` IN (&apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;9&apos;, &apos;17&apos;, &apos;18&apos;, &apos;19&apos;, &apos;20&apos;, &apos;21&apos;))  ORDER BY `h_room_item`.`id` LIMIT 24;</span><br></pre></td></tr></table></figure><p>使用desc或者explain来分析sql语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc SELECT `h_room_item`.`id`, `h_room_item`.`num`, `h_room_item`.`code`, </span><br><span class="line">`h_order`.`ord_no`, `h_order`.`stat`, `h_order`.`sex`, `h_order`.`end_dat`, </span><br><span class="line">`h_order`.`start_dat`, `h_item_flag`.`flag_id` FROM `h_room_item` LEFT JOIN </span><br><span class="line">`h_item_flag` ON h_item_flag.room_id=h_room_item.id LEFT JOIN `h_order` ON </span><br><span class="line">h_order.room_no=h_room_item.num and h_order.code=h_room_item.code WHERE </span><br><span class="line">(`h_room_item`.`code`=&apos;qt001&apos;) AND (`h_item_flag`.`flag_id` IN (&apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;9&apos;, &apos;17&apos;, &apos;18&apos;, </span><br><span class="line">&apos;19&apos;, &apos;20&apos;, &apos;21&apos;))  ORDER BY `h_room_item`.`id` LIMIT 24\G;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: h_item_flag</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 28</span><br><span class="line">        Extra: Using where; Using temporary; Using filesort</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: h_room_item</span><br><span class="line">         type: eq_ref</span><br><span class="line">possible_keys: PRIMARY,index2</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: hotel_door.h_item_flag.room_id</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using where</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: h_order</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: index3</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 10</span><br><span class="line">        Extra: Using where; Using join buffer (flat, BNL join)</span><br><span class="line">3 rows in set (0.60 sec)</span><br></pre></td></tr></table></figure><h4 id="可能原因："><a href="#可能原因：" class="headerlink" title="可能原因："></a>可能原因：</h4><ul><li>1、没有索引或者没有用到索引(这是查询慢最常见的问题，是程序设计的缺陷)</li><li>2、I/O吞吐量小，形成了瓶颈效应。</li><li>3、没有创建计算列导致查询不优化。</li><li>4、内存不足</li><li>5、网络速度慢</li><li>6、查询出的数据量过大(可以采用多次查询，其他的方法降低数据量)</li><li>7、锁或者死锁(这也是查询慢最常见的问题，是程序设计的缺陷)</li><li>8、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。</li><li>9、返回了不必要的行和列</li><li>10、查询语句不好，没有优化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;定位慢查询sql语句&quot;&gt;&lt;a href=&quot;#定位慢查询sql语句&quot; class=&quot;headerlink&quot; title=&quot;定位慢查询sql语句&quot;&gt;&lt;/a&gt;定位慢查询sql语句&lt;/h4&gt;&lt;p&gt;可以通过开启慢查询来将所有的慢查询记录到某个文件里面，这里以slow-que
      
    
    </summary>
    
      <category term="技能" scheme="http://blog.inbelieve.top/categories/skill/"/>
    
    
      <category term="MySQL" scheme="http://blog.inbelieve.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>读汪国真的诗</title>
    <link href="http://blog.inbelieve.top/life/20180617-0.html"/>
    <id>http://blog.inbelieve.top/life/20180617-0.html</id>
    <published>2018-06-17T08:07:56.000Z</published>
    <updated>2018-06-27T13:09:47.849Z</updated>
    
    <content type="html"><![CDATA[<p>最近在箱子里收拾下东西，翻到了以前的一本笔记本，拿来看一下，发现是以前读过并抄下来的诗歌，其中几首是汪国真的诗歌，他的诗歌总是充满了阳光和青春，读他的诗总能体会到青春的味道。下面我把他们贴出来</p><p>####《热爱生命》<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我不去想是否能够成功</span><br><span class="line"></span><br><span class="line">既然选择了远方</span><br><span class="line"></span><br><span class="line">便只顾风雨兼程</span><br><span class="line"></span><br><span class="line">我不去想能否赢得爱情</span><br><span class="line"></span><br><span class="line">既然钟情于玫瑰</span><br><span class="line"></span><br><span class="line">就勇敢地吐露真诚</span><br><span class="line"></span><br><span class="line">我不去想身后会不会袭来寒风冷雨</span><br><span class="line"></span><br><span class="line">既然目标是地平线</span><br><span class="line"></span><br><span class="line">留给世界的只能是背影</span><br><span class="line"></span><br><span class="line">我不去想未来是平坦还是泥泞</span><br><span class="line"></span><br><span class="line">只要热爱生命</span><br><span class="line"></span><br><span class="line">一切，都在意料之中</span><br></pre></td></tr></table></figure></p><p>####《感谢》</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">让我怎样感谢你</span><br><span class="line"></span><br><span class="line">当我走向你的时候</span><br><span class="line"></span><br><span class="line">我原想收获一缕春风</span><br><span class="line"></span><br><span class="line">你却给了我整个春天</span><br><span class="line"></span><br><span class="line">让我怎样感谢你</span><br><span class="line"></span><br><span class="line">当我走向你的时候</span><br><span class="line"></span><br><span class="line">我原想捧起一簇浪花</span><br><span class="line"></span><br><span class="line">你却给了我整个海洋</span><br><span class="line"></span><br><span class="line">让我怎样感谢你</span><br><span class="line"></span><br><span class="line">当我走向你的时候</span><br><span class="line"></span><br><span class="line">我原想撷取一枚红叶</span><br><span class="line"></span><br><span class="line">你却给了我整个枫林</span><br><span class="line"></span><br><span class="line">让我怎样感谢你</span><br><span class="line"></span><br><span class="line">当我走向你的时候</span><br><span class="line"></span><br><span class="line">我原想亲吻一朵雪花</span><br><span class="line"></span><br><span class="line">你却给了我银色的世界</span><br></pre></td></tr></table></figure><p>####《学会等待》</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不要因为一次的失败就打不起精神，</span><br><span class="line"></span><br><span class="line">每个成功的人背后都有苦衷。</span><br><span class="line"></span><br><span class="line">你看即便像太阳那样辉煌，</span><br><span class="line"></span><br><span class="line">有时也被浮云遮住了光阴。</span><br><span class="line"></span><br><span class="line">你的才华不会永远被埋没，</span><br><span class="line"></span><br><span class="line">除非你自己想把前途葬送。</span><br><span class="line"></span><br><span class="line">你要学会等待和安排自己，</span><br><span class="line"></span><br><span class="line">成功其实不需要太多酒精。</span><br><span class="line"></span><br><span class="line">要当英雄不妨先当狗熊，</span><br><span class="line"></span><br><span class="line">怕只怕对什么都无动于衷。</span><br><span class="line"></span><br><span class="line">河上没有桥还可以等待结冰，</span><br><span class="line"></span><br><span class="line">走过漫长的黑夜便是黎明。</span><br></pre></td></tr></table></figure><p>####《嫁给幸福》</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有一个未来的目标</span><br><span class="line"></span><br><span class="line">总能让我们欢欣鼓舞</span><br><span class="line"></span><br><span class="line">就像飞向火光的灰蛾</span><br><span class="line"></span><br><span class="line">甘愿做烈焰的俘虏</span><br><span class="line"></span><br><span class="line">摆动着的是你不停的脚步</span><br><span class="line"></span><br><span class="line">飞旋着的是你美丽的流苏</span><br><span class="line"></span><br><span class="line">在一往情深的日子里</span><br><span class="line"></span><br><span class="line">谁能说得清</span><br><span class="line"></span><br><span class="line">什么是甜 什么是苦</span><br><span class="line"></span><br><span class="line">只知道 确定了就义无返顾</span><br><span class="line"></span><br><span class="line">要输就输给追求</span><br><span class="line"></span><br><span class="line">要嫁就嫁给幸福</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在箱子里收拾下东西，翻到了以前的一本笔记本，拿来看一下，发现是以前读过并抄下来的诗歌，其中几首是汪国真的诗歌，他的诗歌总是充满了阳光和青春，读他的诗总能体会到青春的味道。下面我把他们贴出来&lt;/p&gt;
&lt;p&gt;####《热爱生命》&lt;br&gt;&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="生活" scheme="http://blog.inbelieve.top/categories/life/"/>
    
    
      <category term="诗歌" scheme="http://blog.inbelieve.top/tags/peomtry/"/>
    
  </entry>
  
  <entry>
    <title>心有猛虎，细嗅蔷薇</title>
    <link href="http://blog.inbelieve.top/life/20180617-2.html"/>
    <id>http://blog.inbelieve.top/life/20180617-2.html</id>
    <published>2018-06-17T07:36:25.000Z</published>
    <updated>2018-06-17T01:11:22.632Z</updated>
    
    <content type="html"><![CDATA[<p>In me, past, present, future meet，<br>于我，过去、现在和未来</p><p>To hold long chiding conference.<br>商讨聚会 各执一词 纷扰不息。</p><p>My lusts usurp the present tense<br>林林总总的 欲望，掠取着我的现在</p><p>And strangle Reason in his seat.<br> 把“理性”扼杀于它的宝座</p><p>My loves leap through the future’s fence<br>我的爱情纷纷越过未来的藩篱</p><p>To dance with dream-enfranchised feet.<br>梦想解放出它们的双脚 舞蹈不停</p><p>In me the cave-man clasps the seer,<br>于我，穴居人攫取了先知，</p><p>And garlanded Apollo goes 佩戴花环的阿波罗神</p><p>Chanting to Abraham’s deaf ear.<br>向亚伯拉罕的聋耳唱叹歌吟。</p><p>In me the tiger sniffs the rose.<br>心有猛虎，细嗅蔷薇。</p><p>Look in my heart, kind friends, and tremble,<br>审视我的内心吧，亲爱的朋友，你应颤栗，</p><p>Since there your elements assemble.<br>因为那才是你本来的面目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In me, past, present, future meet，&lt;br&gt;于我，过去、现在和未来&lt;/p&gt;
&lt;p&gt;To hold long chiding conference.&lt;br&gt;商讨聚会 各执一词 纷扰不息。&lt;/p&gt;
&lt;p&gt;My lusts usurp the pr
      
    
    </summary>
    
      <category term="生活" scheme="http://blog.inbelieve.top/categories/life/"/>
    
    
      <category term="诗歌" scheme="http://blog.inbelieve.top/tags/peomtry/"/>
    
  </entry>
  
  <entry>
    <title>更改pip源为国内镜像地址</title>
    <link href="http://blog.inbelieve.top/server/20180616-7.html"/>
    <id>http://blog.inbelieve.top/server/20180616-7.html</id>
    <published>2018-06-16T09:31:09.000Z</published>
    <updated>2018-06-27T13:15:50.249Z</updated>
    
    <content type="html"><![CDATA[<p>经常在使用python的时候需要安装各种模块，而pip是很强大的模块安装工具，但是由于国外官方pypi经常被墙，导致不可用，所以我们最好是将自己使用的pip源更换一下，这样就能解决被墙导致的装不上库的烦恼。</p><hr><h4 id="修改源"><a href="#修改源" class="headerlink" title="修改源"></a>修改源</h4><p>以ubuntu16.04为例进行说明。</p><p>国内源（新版ubuntu要求使用https源，要注意。）：</p><ul><li>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></li><li>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></li><li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>豆瓣：<a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></li></ul><p>还有一些别的没有列出。</p><h6 id="临时使用："><a href="#临时使用：" class="headerlink" title="临时使用："></a>临时使用：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider</span><br></pre></td></tr></table></figure><h6 id="永久修改："><a href="#永久修改：" class="headerlink" title="永久修改："></a>永久修改：</h6><ul><li><p>Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)，内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]  </span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/ </span><br><span class="line">[install]  </span><br><span class="line">trusted-host=mirrors.aliyun.com  </span><br><span class="line">timeout = 150 # 超时时间设置(单位为s)，一般可以设置的长一些</span><br></pre></td></tr></table></figure></li><li><p>windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini，内容如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经常在使用python的时候需要安装各种模块，而pip是很强大的模块安装工具，但是由于国外官方pypi经常被墙，导致不可用，所以我们最好是将自己使用的pip源更换一下，这样就能解决被墙导致的装不上库的烦恼。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;修改源&quot;&gt;&lt;a href=&quot;#修
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Python" scheme="http://blog.inbelieve.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>centos7上安装nginx+uwsgi搭建项目</title>
    <link href="http://blog.inbelieve.top/server/20180616-6.html"/>
    <id>http://blog.inbelieve.top/server/20180616-6.html</id>
    <published>2018-06-16T09:30:48.000Z</published>
    <updated>2018-06-27T13:15:34.654Z</updated>
    
    <content type="html"><![CDATA[<p>*安装nginx<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum instal  nginx</span><br></pre></td></tr></table></figure></p><ul><li><p>使用pip安装uwsgi</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install uwsgi</span><br></pre></td></tr></table></figure></li><li><p>新建配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /etc/uwsgi</span><br><span class="line">vim /etc/uwsgi/uwsgi.ini</span><br></pre></td></tr></table></figure></li><li><p>配置uwsgi</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:9090</span><br><span class="line">master = true         </span><br><span class="line">wsgi-file=/var/www/html/python/test.py</span><br><span class="line">#vhost = true          </span><br><span class="line">no-site = true        </span><br><span class="line">workers = 2           </span><br><span class="line">reload-mercy = 10     </span><br><span class="line">vacuum = true        </span><br><span class="line">max-requests = 1000   </span><br><span class="line">limit-as = 512</span><br><span class="line">buffer-size = 30000</span><br><span class="line">pidfile = /var/run/uwsgi9090.pid    </span><br><span class="line">daemonize = /var/log/uwsgi9090.log</span><br></pre></td></tr></table></figure></li><li><p>配置test.py文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /var/www/html/python/</span><br><span class="line">vim test.py</span><br></pre></td></tr></table></figure></li></ul><p>写文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def application(env, start_response):</span><br><span class="line">    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;,&apos;text/html&apos;)])</span><br><span class="line">    return &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></p><ul><li>配置nginx<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/python.conf</span><br></pre></td></tr></table></figure></li></ul><p>插入下面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8090;</span><br><span class="line">    server_name 127.0.0.1;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">include  uwsgi_params;</span><br><span class="line">        uwsgi_pass  127.0.0.1:9090;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br><span class="line">uwsgi /etc/uwsgi/uwsgi.ini</span><br></pre></td></tr></table></figure></li><li><p>访问,在浏览器上输入10.104.15.150:9090（此时ip换成你的linux机器ip）</p><figure class="image-box">                <img src="https://upload-images.jianshu.io/upload_images/2860230-a9710bf50d5bd3ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1524623005.jpg" title="" class="">                <p>1524623005.jpg</p>            </figure></li></ul><p>如此，则成功了，接下来你可以愉快地使用python进行项目开发了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;*安装nginx&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum instal  nginx&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Linux" scheme="http://blog.inbelieve.top/tags/linux/"/>
    
      <category term="Centos" scheme="http://blog.inbelieve.top/tags/centos/"/>
    
      <category term="Python" scheme="http://blog.inbelieve.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>启动docker服务找不到group docker报错处理</title>
    <link href="http://blog.inbelieve.top/server/20180616-5.html"/>
    <id>http://blog.inbelieve.top/server/20180616-5.html</id>
    <published>2018-06-16T09:30:22.000Z</published>
    <updated>2018-06-27T13:14:47.486Z</updated>
    
    <content type="html"><![CDATA[<p>最近在安装docker时发现，启动docker服务时发现提示下面的出错信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">could not change group /var/run/docker.sock to docker: group docker not found</span><br></pre></td></tr></table></figure></p><p>后来查了一下原因，发现这是因为cgroup没有挂载的原因，只要把cgroup挂载好就OK了，挂载方法如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line">#在最后一行增加以下配置信息：</span><br><span class="line">none        /sys/fs/cgroup        cgroup        defaults    0    0</span><br></pre></td></tr></table></figure></p><p>保存退出，在启动试一下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure></p><p>发现docker服务已经成功跑起来了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在安装docker时发现，启动docker服务时发现提示下面的出错信息&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;could not ch
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Docker" scheme="http://blog.inbelieve.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker基本命令详解</title>
    <link href="http://blog.inbelieve.top/server/20180616-4.html"/>
    <id>http://blog.inbelieve.top/server/20180616-4.html</id>
    <published>2018-06-16T09:29:41.000Z</published>
    <updated>2018-06-27T13:13:12.591Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>attach:    将标准输入（stdin）与标准输出（stdout）连接到正在运行的容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br><span class="line"># 创建容器</span><br><span class="line">docker create -it --name centos-container centos /bin/bash</span><br><span class="line"># 若想使用刚刚创建的容器，则必须使用docker start 命令启动容器</span><br><span class="line">docker start centos-container</span><br><span class="line"># 进入容器内部</span><br><span class="line">docker attach centos-container</span><br></pre></td></tr></table></figure></li><li><p>build:     使用Dockerfile文件创建镜像 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build &lt;选项&gt;&lt;Dockerfile路径&gt;</span><br></pre></td></tr></table></figure></li><li><p>commit:    从容器的修改项创建显得镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit &lt;选项&gt;&lt;容器名称，id&gt;/&lt;镜像名称&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure></li><li><p>cp:        用于将容器的目录或文件复制的到主机。若将cp命令中的路径设置为目录，则将该目录下的所有内容复制到主机</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br><span class="line"># 将容器内的整个/etc 目录复制到主机当前文件夹下</span><br><span class="line">docker cp centos-container:/etc /home/long</span><br></pre></td></tr></table></figure></li><li><p>create:    使用指定的镜像创建容器。与run命令不同，使用create命令只能创建容器而并不启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"># 创建容器</span><br><span class="line">docker create -it --name centos-container centos /bin/bash</span><br><span class="line"># 若想使用刚刚创建的容器，则必须使用docker start 命令启动容器</span><br><span class="line">docker start centos-container</span><br><span class="line"># 进入容器内部</span><br><span class="line">docker attach centos-container</span><br><span class="line"># 退出容器</span><br><span class="line">exit</span><br><span class="line"># 停止容器</span><br><span class="line">docker stop centos-container</span><br></pre></td></tr></table></figure></li><li><p>diff:      检查容器文件系统的修改(查看修改内容)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker diff &lt;容器名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">[root@localhost /home/long]# docker diff centos-container</span><br><span class="line">C /run</span><br><span class="line">A /run/secrets</span><br><span class="line">C /root</span><br><span class="line">A /root/.bash_history</span><br></pre></td></tr></table></figure></li><li><p>events:    实时输出Docker服务器中发生的事件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker events</span><br><span class="line">另一终端，运行容器</span><br><span class="line">docker start centos-container</span><br><span class="line">此端输出</span><br><span class="line">2018-04-26T19:16:35.017678507-07:00 network connect b2376bcc00f587966645b362992289aa78ea58080ea6713a9a418b5f82e64c48 (container=24d1711909362e7620f9c76f266a671f1a7336452e88ff32c4942a4768801d79, name=bridge, type=bridge)</span><br><span class="line">2018-04-26T19:16:35.622752724-07:00 container start 24d1711909362e7620f9c76f266a671f1a7336452e88ff32c4942a4768801d79 (build-date=20170911, image=centos, license=GPLv2, name=centos-container, vendor=CentOS)</span><br></pre></td></tr></table></figure></li><li><p>exec:      用于从外部运行容器内部的命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"># 执行</span><br><span class="line">docker exec -it hello /bin/bash</span><br><span class="line">ps -ef</span><br></pre></td></tr></table></figure></li><li><p>export:    将容器的文件系统导出为tar文件包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker export &lt;容器名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker export centos-container &gt; centos-container.tar</span><br></pre></td></tr></table></figure></li><li><p>history:   显示镜像的历史。此处的历史依据Dockerfile文件中的设置创建。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker history &lt;选项&gt;&lt;镜像名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">[root@localhost /home/long]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/tomcat    latest              33e02377a00f        2 weeks ago         553.8 MB</span><br><span class="line">docker.io/nginx     latest              b175e7467d66        2 weeks ago         108.9 MB</span><br><span class="line">docker.io/centos    latest              196e0ce0c9fb        7 months ago        196.6 MB</span><br><span class="line">[root@localhost /home/long]# docker history tomcat</span><br></pre></td></tr></table></figure></li><li><p>images:   查看所有镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost /home/long]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/tomcat    latest              33e02377a00f        2 weeks ago         553.8 MB</span><br><span class="line">docker.io/nginx     latest              b175e7467d66        2 weeks ago         108.9 MB</span><br><span class="line">docker.io/centos    latest              196e0ce0c9fb        7 months ago        196.6 MB</span><br></pre></td></tr></table></figure></li><li><p>import:    从压缩为tar文件（.tar .tar.gz .tgz .bzip .tar.xz .txz）的文件系统创建镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker import &lt;tar文件的URL或者 - &gt;&lt;注册名称&gt;/&lt;镜像名称&gt;:&lt;标签&gt;</span><br><span class="line">docker import centos-container.tar centos-container-2</span><br><span class="line">cat centos-container | docker import - centos-container-2</span><br></pre></td></tr></table></figure></li><li><p>info:      显示当前系统信息、docker容器、镜像个数、设置等信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure></li><li><p>inspect:   获得更详细的容器、镜像或者任务信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect &lt;选项&gt;&lt;容器或镜像名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker inspect centos-container</span><br></pre></td></tr></table></figure></li><li><p>kill:      向容器发送KILL信号，从而关闭容器（推荐使用更优雅温和的 docker stop 命令)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker kill centos-container</span><br></pre></td></tr></table></figure></li><li><p>load:      从tar文件或标准输入中创建镜像 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load &lt;选项&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker load -i centos-container.tar</span><br></pre></td></tr></table></figure></li><li><p>login:    登录Docker 的注册服务器,若不设置注册服务器的地址，则默认登录<a href="https://link.segmentfault.com/?r=https%3A%2F%2Fhub.docker.com%2F" target="_blank" rel="noopener">dockerhub</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login &lt;选项&gt;&lt;Docker 注册服务器的URL&gt;</span><br><span class="line">-e、--email=&quot;&quot; 设置登录时使用的电子邮件</span><br><span class="line">-p、--password=&quot;&quot; 设置登录密码</span><br><span class="line">-u、--username=&quot;&quot; 设置登录时使用的账号</span><br></pre></td></tr></table></figure></li><li><p>logout:   从Docker注册服务器中登出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logout &lt;选项&gt;&lt;Docker 注册服务器的URL&gt;</span><br></pre></td></tr></table></figure></li><li><p>logs:     获取容器日志</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs &lt;容器名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker logs centos-container</span><br></pre></td></tr></table></figure></li><li><p>network:   管理docker的网络系统</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network COMMAND</span><br><span class="line"># 示例</span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure></li><li><p>node:      管理docker的swarm集群节点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure></li><li><p>pause:    暂停容器中所有的进程（可以是多个容器）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pause &lt;容器名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker pause centos-container</span><br><span class="line"># 恢复</span><br><span class="line">docker unpause centos-container</span><br></pre></td></tr></table></figure></li><li><p>port:     查看容器的某个端口是否处于开放状态</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker port &lt;容器名称，id&gt;&lt;端口&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker port centos-container 8090</span><br></pre></td></tr></table></figure></li><li><p>ps:        查看容器列表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps &lt;选项&gt;</span><br><span class="line">-a、--all=false 列出所有容器。不带 -a 只输出在运行的容器</span><br><span class="line">--before=&quot;&quot; 列出特定容器创建前的容器，包含停止的容器。</span><br><span class="line">-f、--filter=[] 设置输出过滤。如 &quot;exited=0&quot;</span><br><span class="line">-l、--latest=false 列出最后创建的容器，包含停止的容器</span><br><span class="line">-q、--quiet=false 只输出容器的id</span><br><span class="line"># 示例</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>pull:      从一个远程仓库拉取镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull &lt;选项&gt; &lt;镜像名&gt;:&lt;标签&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure></li><li><p>push:      将镜像推送到Docker注册服务器或者指定仓库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker push &lt;注册名&gt;/&lt;镜像名&gt;:&lt;标签&gt;</span><br><span class="line">docker pull 192.168.1.150:10000/centos-container:latest</span><br></pre></td></tr></table></figure></li><li><p>rename:    修改某一个容器名字</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rename  &lt;容器名&gt; &lt;新容器名&gt;</span><br><span class="line"># 示例</span><br><span class="line"> docker rename centos-container centos</span><br></pre></td></tr></table></figure></li><li><p>restart:   重启容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart &lt;容器名称，id&gt;</span><br><span class="line">docker restart centos-container</span><br></pre></td></tr></table></figure></li><li><p>rm:       删除容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm &lt;容器名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker ps -a</span><br><span class="line">docker rm hello</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>rmi:       删除镜像, 若不指定标签，则删除latest标签</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi &lt;注册名称&gt;/&lt;镜像名称，id&gt;:&lt;标签&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker images</span><br><span class="line">docker nginx</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure></li><li><p>run:      使用命令行指定镜像创建容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run &lt;选项&gt;&lt;镜像名称，id&gt;&lt;命令&gt;&lt;参数&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker ps -a</span><br><span class="line">docker run --name hello -i -t centos /bin/bash</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>save:      将镜像保存为tar包文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;</span><br><span class="line"># 示例</span><br><span class="line">[root@localhost /home/long]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/tomcat    latest              33e02377a00f        2 weeks ago         553.8 MB</span><br><span class="line">docker.io/nginx     latest              b175e7467d66        2 weeks ago         108.9 MB</span><br><span class="line">docker.io/centos    latest              196e0ce0c9fb        7 months ago        196.6 MB</span><br><span class="line">[root@localhost /home/long]# docker save nginx -o nginx.tar</span><br><span class="line">[root@localhost /home/long]# ll</span><br><span class="line">total 110028</span><br><span class="line">drwxr-xr-x. 2 long long         6 Sep 28  2017 Desktop</span><br><span class="line">drwxr-xr-x. 2 long long         6 Sep 28  2017 Documents</span><br><span class="line">drwxr-xr-x. 2 long long         6 Sep 28  2017 Downloads</span><br><span class="line">drwxr-xr-x. 2 long long         6 Sep 28  2017 Music</span><br><span class="line">-rw-------. 1 root root 112667648 Apr 26 22:46 nginx.tar #生成了新的文件</span><br><span class="line">drwxr-xr-x. 2 long long         6 Sep 28  2017 Pictures</span><br><span class="line">drwxr-xr-x. 2 long long         6 Sep 28  2017 Public</span><br><span class="line">drwxr-xr-x. 2 long long        61 Oct 17  2017 samba</span><br><span class="line">drwxr-xr-x. 2 long long         6 Sep 28  2017 Templates</span><br><span class="line">drwxr-xr-x. 2 long long         6 Sep 28  2017 Videos</span><br><span class="line">[root@localhost /home/long]#</span><br></pre></td></tr></table></figure></li><li><p>search:    根据名字在docker hub搜索你要的镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search &lt;选项&gt;&lt;搜索词&gt;</span><br><span class="line">--automated=false 只显示由docker hub 的automated build 创建的镜像</span><br><span class="line">--no-trunc=false 显示所有因因为内容过长而省略的部分</span><br><span class="line">-s、--stars=0 显示滴啊有特定星级以上的镜像</span><br><span class="line"># 示例</span><br><span class="line">docker search nginx</span><br></pre></td></tr></table></figure></li><li><p>service:   管理docker服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service [COMMAND]</span><br><span class="line">docker service ls #主要用于swarm集群</span><br></pre></td></tr></table></figure></li><li><p>start:     启动一个或多个容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start &lt;选项&gt;&lt;容器名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker start centos-container</span><br></pre></td></tr></table></figure></li><li><p>stats:     显示一个容器的使用资源情况，包括cpu，内存，硬盘等</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stats &lt;选项&gt;&lt;容器名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker stats centos-container</span><br></pre></td></tr></table></figure></li><li><p>stop:      停止容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop&lt;选项&gt;&lt;容器或镜像名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker stop centos-container</span><br></pre></td></tr></table></figure></li><li><p>swarm:     管理Docker Swarm集群</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm [COMMAND]</span><br><span class="line"># 初始化一个swarm集群</span><br><span class="line">docker swarm init</span><br></pre></td></tr></table></figure></li><li><p>tag:       标记本地镜像，将其归入某一仓库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;&lt;注册地址，用户名&gt;/&lt;镜像名称&gt;:&lt;标签&gt;</span><br><span class="line">#示例</span><br><span class="line">docker tag nginx:latest youset:6666/nginx:0.1</span><br></pre></td></tr></table></figure></li><li><p>top:      显示容器中正在运行的进程信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker top &lt;容器名称，id&gt;&lt;ps选项&gt;</span><br><span class="line">#示例</span><br><span class="line">docker top centos-container</span><br></pre></td></tr></table></figure></li><li><p>unpause:   停止容器内的所有进程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker unpause &lt;容器名称，id&gt;</span><br><span class="line">#示例</span><br><span class="line">docker unpause centos-container</span><br></pre></td></tr></table></figure></li><li><p>update:    动态地更新容器配置。可以使用这个命令限制容器在docker主机上使用太多的资源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker update &lt;容器名称，id&gt;</span><br><span class="line">#示例</span><br><span class="line">doucker update centos-container</span><br></pre></td></tr></table></figure></li><li><p>version:   展示docker版本信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost /home/long]# docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:         1.12.6</span><br><span class="line"> API version:     1.24</span><br><span class="line"> Package version: docker-1.12.6-55.gitc4618fb.el7.centos.x86_64</span><br><span class="line"> Go version:      go1.8.3</span><br><span class="line"> Git commit:      c4618fb/1.12.6</span><br><span class="line"> Built:           Thu Sep 21 22:33:52 2017</span><br><span class="line"> OS/Arch:         linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:         1.12.6</span><br><span class="line"> API version:     1.24</span><br><span class="line"> Package version: docker-1.12.6-55.gitc4618fb.el7.centos.x86_64</span><br><span class="line"> Go version:      go1.8.3</span><br><span class="line"> Git commit:      c4618fb/1.12.6</span><br><span class="line"> Built:           Thu Sep 21 22:33:52 2017</span><br><span class="line"> OS/Arch:         linux/amd64</span><br></pre></td></tr></table></figure></li><li><p>volume:    管理docker数据卷</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br><span class="line"># 示例</span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure></li><li><p>wait:      等待容器终止，然后输出 Exit Code</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker wait &lt;容器名称，id&gt;</span><br><span class="line"># 示例</span><br><span class="line">docker wait centos-container</span><br></pre></td></tr></table></figure></li></ul><p>以上就是docker的主要命令，包括docker swarm集群的一些命令，除此之外还有一些其他的命令,如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--api-enable-cors=false 使用API时，启用CORS（cross-origin resource sharing）</span><br><span class="line"></span><br><span class="line">-b 、--bridge=&quot;&quot; 使用事先创建的网桥接口。若设置为none，则不在容器内使用网络</span><br><span class="line"></span><br><span class="line">--bip=&quot;&quot; 使用CIDR标记法设置docker 的IP带宽。该选项不能与-b选项同时使用</span><br><span class="line"></span><br><span class="line">如：`-bip=&quot;192.168.0.0/24&quot;`</span><br><span class="line">-D 、--debug 启用调试模式</span><br><span class="line"></span><br><span class="line">-d 、--deamon=false 以守护进程模式运行</span><br><span class="line"></span><br><span class="line">--dns 设置docker要使用的DNS服务器</span><br><span class="line"></span><br><span class="line">--dns-search=[] 设置docker要使用的DNS搜索域。若设置为：example.com，则向服务器查询hello时，将首先查找hello.example.com</span><br><span class="line"></span><br><span class="line">-e、--exec-drive=&quot;native&quot; 设置docker运行驱动，可设置为Native与lxc</span><br><span class="line"></span><br><span class="line">--fixed-cidr=&quot;&quot; 固定分配IPv4地址的带宽。该IP地址必须在-b选项设置的网桥网络或--bip设置的IP网段内</span><br><span class="line"></span><br><span class="line">-G、--group=&quot;docker&quot; 以守护进程模式运行时，使用-H选项创建Unix套接字后，设置该Unix套接字所在的组。使用&quot;&quot;空字符串表示不设置分组</span><br><span class="line"></span><br><span class="line">-g、 --graph=&quot;/var/lib/docker&quot; 设置docker使用目录的顶层路径</span><br><span class="line"></span><br><span class="line">-H、--host[] 以守护进程模式运行时，设置套接字路径。</span><br><span class="line"></span><br><span class="line">--icc=true 开启容器间通信</span><br><span class="line"></span><br><span class="line">--insecure-registry=[] 使用私有证书搭建docker注册服务器时，设置docker注册服务器域名</span><br><span class="line"></span><br><span class="line">--ip=0.0.0.0 使用docker run 命令时-p选项将端口暴露在外时，设置要绑定的默认IP地址</span><br><span class="line"></span><br><span class="line">--ip-forward=true 开启net.ipv4.ip_forward</span><br><span class="line"></span><br><span class="line">--ip-masq=true 为网桥上的IP地址开启IP伪装（masquerading）</span><br><span class="line"></span><br><span class="line">--iptables=true 开启iptables规则</span><br><span class="line"></span><br><span class="line">--mtu=0 设置容器的网络最大传输单元（MTU, Maxmum transmission unit）若不设置，则使用路由器的默认MTU或者设置为1500</span><br><span class="line"></span><br><span class="line">-p、--pidfile=&quot;/var/run/docker.pid&quot; 设置PID文件路径</span><br><span class="line"></span><br><span class="line">-registry-mirror=[] 设置docker registry 的镜像地址</span><br><span class="line"></span><br><span class="line">-s、--storage-driver=[] 设置储存驱动，默认为auto，也可以设置为drivcemapper</span><br><span class="line"></span><br><span class="line">--selinux-enabled=false开启SELinux SELinux尚不支持BTRFS储存驱动</span><br><span class="line"></span><br><span class="line">--storage-opt 设置存储驱动选项</span><br><span class="line"></span><br><span class="line">--tls=false 使用TLS</span><br><span class="line"></span><br><span class="line">--tlscacert=&quot;/home/exapmleuser/.docker/ca.pem&quot; 设置要在远程证书中使用的CA证书文件的路径</span><br><span class="line"></span><br><span class="line">--tlscert=&quot;/home/exapmleuser/.docker/cert.pem&quot; 设置证书文件路径</span><br><span class="line"></span><br><span class="line">--tlskey=&quot;/home/exapmleuser/.docker/key.pem&quot; 设置密匙文件路径</span><br><span class="line"></span><br><span class="line">tlsverify=&quot;false&quot; 使用TLS远程证书，守护进程与客户端全部使用证书验证</span><br><span class="line"></span><br><span class="line">-v、--version=false 打印版本信息</span><br></pre></td></tr></table></figure></p><h6 id="docker一个很有意思的东西，如果你还在纠结于每次装完软件后，要更新软件无法删除所有的文件时，你不妨考虑一下使用docker-他让你可以快速部署，快速清除，快捷方便。"><a href="#docker一个很有意思的东西，如果你还在纠结于每次装完软件后，要更新软件无法删除所有的文件时，你不妨考虑一下使用docker-他让你可以快速部署，快速清除，快捷方便。" class="headerlink" title="docker一个很有意思的东西，如果你还在纠结于每次装完软件后，要更新软件无法删除所有的文件时，你不妨考虑一下使用docker,他让你可以快速部署，快速清除，快捷方便。"></a>docker一个很有意思的东西，如果你还在纠结于每次装完软件后，要更新软件无法删除所有的文件时，你不妨考虑一下使用docker,他让你可以快速部署，快速清除，快捷方便。</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;attach:    将标准输入（stdin）与标准输出（stdout）连接到正在运行的容器&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Docker" scheme="http://blog.inbelieve.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>设置rubygems国内镜像地址</title>
    <link href="http://blog.inbelieve.top/server/20180616-3.html"/>
    <id>http://blog.inbelieve.top/server/20180616-3.html</id>
    <published>2018-06-16T09:29:14.000Z</published>
    <updated>2018-06-16T23:50:52.015Z</updated>
    
    <content type="html"><![CDATA[<p>安装完ruby和rubygems后发现gem下载包很慢，这是因为gem的仓库地址是国外的原因。</p><p>我查了一下，发现国内有镜像<a href="https://gems.ruby-china.org/可以使用，现在我们来把它设置成国内镜像。" target="_blank" rel="noopener">https://gems.ruby-china.org/可以使用，现在我们来把它设置成国内镜像。</a></p><h5 id="查看gem是否安装"><a href="#查看gem是否安装" class="headerlink" title="查看gem是否安装"></a>查看gem是否安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gem -v</span><br><span class="line">2.5.1</span><br></pre></td></tr></table></figure><h5 id="更换源地址"><a href="#更换源地址" class="headerlink" title="更换源地址"></a>更换源地址</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</span><br><span class="line">$ gem sources -l</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line">https://gems.ruby-china.org/</span><br></pre></td></tr></table></figure><h5 id="SSL-证书错误"><a href="#SSL-证书错误" class="headerlink" title="SSL 证书错误"></a>SSL 证书错误</h5><p>正常情况下，你是不会遇到 SSL 证书错误的，除非你的 Ruby 安装方式不正确。</p><p>如果遇到 SSL 证书问题，你又无法解决，请修改 ~/.gemrc 文，增加 ssl_verify_mode: 0 配置，以便于 RubyGems 可以忽略 SSL 证书错误。</p><ul><li><p>linux</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">:sources:</span><br><span class="line">- https://gems.ruby-china.org</span><br><span class="line">:ssl_verify_mode: 0</span><br></pre></td></tr></table></figure></li><li><p>windows<br>下载 <a href="https://curl.haxx.se/ca/cacert.pem(这里我使用mingw64下载)" target="_blank" rel="noopener">https://curl.haxx.se/ca/cacert.pem(这里我使用mingw64下载)</a><br>把文件cacert.pem放到一个目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">curl https://curl.haxx.se/ca/cacert.pem --silent -O</span><br></pre></td></tr></table></figure></li></ul><p>通过系统-&gt;高级系统设置-&gt;环境变量设置SSL_CERT_FILE,然后重新执行配置操作(关闭当前命令行在开)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装完ruby和rubygems后发现gem下载包很慢，这是因为gem的仓库地址是国外的原因。&lt;/p&gt;
&lt;p&gt;我查了一下，发现国内有镜像&lt;a href=&quot;https://gems.ruby-china.org/可以使用，现在我们来把它设置成国内镜像。&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="后台" scheme="http://blog.inbelieve.top/categories/server/"/>
    
    
      <category term="Ruby" scheme="http://blog.inbelieve.top/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>关于竞争</title>
    <link href="http://blog.inbelieve.top/life/20180616-2.html"/>
    <id>http://blog.inbelieve.top/life/20180616-2.html</id>
    <published>2018-06-16T09:28:43.000Z</published>
    <updated>2018-06-16T23:57:37.389Z</updated>
    
    <content type="html"><![CDATA[<p>昨夜，我2年来第一次熬夜看球赛，NBA骑士和步行者的抢七，这次系列赛可以说荡气回肠，从场均40多分钟上场时间，拼到流血的勒布朗·詹姆斯到即使到了最后一刻也不放弃的步行者，每一刻都充满了热血，充满了身体对抗，充满了竞争，我为了他们产生由衷的敬仰。</p><figure class="image-box">                <img src="https://upload-images.jianshu.io/upload_images/2860230-93134d7ba1d2de16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="odzo-fzvpatr2859339.jpg" title="" class="">                <p>odzo-fzvpatr2859339.jpg</p>            </figure><p>依然记得那年的步行者五虎和热火东部大战，而如今，步行者已经从格兰杰到保罗乔治，再到奥拉迪波，他们每场都打得很顽强，将身体一次次的抛向空中，倒地，站起来，退房。如果这个世界能代表无与伦比的竞争精神，我想这就是——不服输不认输，never give up.</p><p>骑士，这只千疮百孔的球队，这一夜梦回2016，詹姆斯腿抽筋继续战斗，被认为是八贤王的TT如同天神下凡吧，这种斗志，一步一步的拖着骑士前行。</p><p>步行者，被打散2次，重建2次，还是詹姆斯的对手，奥拉迪波，这个上年被称为毒药合同的<code>废物</code>，今年带着不屈的精神，进了全明星，东部第五，让无数人震惊；这一夜，二十一岁的特纳和二十一岁的萨博尼斯抢七，二十一岁的特纳，看着最后时刻自己被六犯罚下无法为球队提供帮助时，无能为力的痛哭；奥拉迪波没法拯救球队，再球队输了之后立刻联系训练师，开启了新的征程，走向更加伟大的路；这都是来自于内心强大的竞争本性。</p><p>篮球的魅力就是如此——竞争，这种和世界上其他任何职业都一样的东西，不服输。这是最优秀的品质之一，各行各业皆是如此。最后祝愿骑士胜利，步行者来年能更加强大，成长的代价就是如此——残酷，坚韧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨夜，我2年来第一次熬夜看球赛，NBA骑士和步行者的抢七，这次系列赛可以说荡气回肠，从场均40多分钟上场时间，拼到流血的勒布朗·詹姆斯到即使到了最后一刻也不放弃的步行者，每一刻都充满了热血，充满了身体对抗，充满了竞争，我为了他们产生由衷的敬仰。&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
      <category term="生活" scheme="http://blog.inbelieve.top/categories/life/"/>
    
    
      <category term="存档" scheme="http://blog.inbelieve.top/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>Linux上安装git</title>
    <link href="http://blog.inbelieve.top/skill/20180616-1.html"/>
    <id>http://blog.inbelieve.top/skill/20180616-1.html</id>
    <published>2018-06-16T09:27:35.000Z</published>
    <updated>2018-06-27T13:18:15.767Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>centos</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">yum install git-core</span><br><span class="line"># 查看</span><br><span class="line">git version</span><br><span class="line"># 配置用户名和邮箱</span><br><span class="line">git config --global user.name xxx</span><br><span class="line">git config --global user.email xxxx@xx.com</span><br><span class="line"># 生成公钥私钥对</span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></li><li><p>debian/ubuntu</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装</span><br><span class="line"># 安装</span><br><span class="line">apt-get install git</span><br><span class="line"># 查看</span><br><span class="line">git version</span><br><span class="line"># 配置用户名和邮箱</span><br><span class="line">git config --global user.name xxx</span><br><span class="line">git config --global user.email xxxx@xx.com</span><br><span class="line"># 生成公钥私钥对</span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></li></ul><h5 id="接下来，你就可以愉快使用git了！"><a href="#接下来，你就可以愉快使用git了！" class="headerlink" title="接下来，你就可以愉快使用git了！"></a>接下来，你就可以愉快使用git了！</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;centos&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 安装&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="技能" scheme="http://blog.inbelieve.top/categories/skill/"/>
    
    
      <category term="Git" scheme="http://blog.inbelieve.top/tags/git/"/>
    
      <category term="Linux" scheme="http://blog.inbelieve.top/tags/linux/"/>
    
      <category term="Centos" scheme="http://blog.inbelieve.top/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令大全</title>
    <link href="http://blog.inbelieve.top/skill/20180616-0.html"/>
    <id>http://blog.inbelieve.top/skill/20180616-0.html</id>
    <published>2018-06-16T09:27:14.000Z</published>
    <updated>2018-06-17T00:00:38.277Z</updated>
    
    <content type="html"><![CDATA[<p>本来打算写一篇git命令大全的，但是看到别人也写了一篇，而且挺全面的，也就转过来，他山之石，可以攻玉，希望对大家有所帮助。原文地址：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p><p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令<br><figure class="image-box">                <img src="https://upload-images.jianshu.io/upload_images/2860230-4392aff96095b671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bg2015120901.png" title="" class="">                <p>bg2015120901.png</p>            </figure><br>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Workspace：工作区</span><br><span class="line">*   Index / Stage：暂存区</span><br><span class="line">*   Repository：仓库区（或本地仓库）</span><br><span class="line">*   Remote：远程仓库</span><br></pre></td></tr></table></figure></p><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的代码差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog# 从本地master拉取代码更新当前分支：branch 一般为master$ git rebase [branch]</span><br></pre></td></tr></table></figure><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本来打算写一篇git命令大全的，但是看到别人也写了一篇，而且挺全面的，也就转过来，他山之石，可以攻玉，希望对大家有所帮助。原文地址：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&quot; t
      
    
    </summary>
    
      <category term="技能" scheme="http://blog.inbelieve.top/categories/skill/"/>
    
    
      <category term="Git" scheme="http://blog.inbelieve.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>form-data、x-www-form-urlencoded、raw、binary的区别</title>
    <link href="http://blog.inbelieve.top/frontend/arch1.html"/>
    <id>http://blog.inbelieve.top/frontend/arch1.html</id>
    <published>2018-03-27T22:07:52.000Z</published>
    <updated>2018-06-16T01:06:53.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="form-data"><a href="#form-data" class="headerlink" title="form-data:"></a>form-data:</h3><p>就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型;content-disposition，用来说明字段的一些信息；</p><p>由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。</p><figure class="image-box">                <img src="/frontend/./arch1/1522160210.png" alt="request" title="" class="">                <p>request</p>            </figure><figure class="image-box">                <img src="/frontend/./arch1/1522160289.png" alt="request" title="" class="">                <p>request</p>            </figure><h3 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded:"></a>x-www-form-urlencoded:</h3><p>就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对，比如,name=admin&amp;password = 123123</p><figure class="image-box">                <img src="/frontend/./arch1/1522160820.png" alt="request" title="" class="">                <p>request</p>            </figure><figure class="image-box">                <img src="/frontend/./arch1/1522160905.png" alt="request" title="" class="">                <p>request</p>            </figure><h3 id="json"><a href="#json" class="headerlink" title="json:"></a>json:</h3><p>application/json的发送和接收序列化后的 JSON 字符串</p><p><img src="/frontend/./arch1/1522161108.png" alt="request"></p><p>服务端：</p><ol><li><p>php用file_get_contents拿Post数据。$_POST[‘test’]取不到数据。</p></li><li><p>然后使用json_decode解码。 原始file_get_contents是字符串？</p></li></ol><h3 id="octet-stream"><a href="#octet-stream" class="headerlink" title="octet-stream:"></a>octet-stream:</h3><p>从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。</p><figure class="image-box">                <img src="/frontend/./arch1/1522161036.png" alt="request" title="" class="">                <p>request</p>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;form-data&quot;&gt;&lt;a href=&quot;#form-data&quot; class=&quot;headerlink&quot; title=&quot;form-data:&quot;&gt;&lt;/a&gt;form-data:&lt;/h3&gt;&lt;p&gt;就是http请求中的multipart/form-data,它会将表单的数据处理
      
    
    </summary>
    
      <category term="大前端" scheme="http://blog.inbelieve.top/categories/frontend/"/>
    
    
      <category term="HTTP" scheme="http://blog.inbelieve.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>免费的编程中文书籍索引</title>
    <link href="http://blog.inbelieve.top/resource/arch2.html"/>
    <id>http://blog.inbelieve.top/resource/arch2.html</id>
    <published>2018-03-21T21:48:00.000Z</published>
    <updated>2018-06-16T01:06:53.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语言无关类"><a href="#语言无关类" class="headerlink" title="语言无关类"></a>语言无关类</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><a href="http://i.linuxtoy.org/docs/guide/index.html" target="_blank" rel="noopener">开源世界旅行手册</a></li><li><a href="http://vbird.dic.ksu.edu.tw/" target="_blank" rel="noopener">鸟哥的Linux私房菜</a></li><li><a href="http://billie66.github.io/TLCL/index.html" target="_blank" rel="noopener">The Linux Command Line</a> (中英文版)</li><li><a href="http://oss.org.cn/kernel-book/ldd3/index.html" target="_blank" rel="noopener">Linux 设备驱动</a> (第三版)</li><li><a href="http://www.kerneltravel.net/kernel-book/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81.html" target="_blank" rel="noopener">深入分析Linux内核源码</a></li><li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml" target="_blank" rel="noopener">UNIX TOOLBOX</a></li><li><a href="https://github.com/widuu/chinese_docker" target="_blank" rel="noopener">Docker中文指南</a></li><li><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">Docker —— 从入门到实践</a></li><li><a href="http://yuedu.baidu.com/ebook/d817967416fc700abb68fca1" target="_blank" rel="noopener">Docker入门实战</a></li><li><a href="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn#docker-cheat-sheet" target="_blank" rel="noopener">Docker Cheat Sheet</a></li><li><a href="http://freeradius.akagi201.org" target="_blank" rel="noopener">FreeRADIUS新手入门</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/" target="_blank" rel="noopener">Mac 开发配置手册</a></li><li><a href="https://www.freebsd.org/doc/zh_CN/books/handbook/index.html" target="_blank" rel="noopener">FreeBSD 使用手册</a></li><li><a href="http://billie66.github.io/TLCL/book/" target="_blank" rel="noopener">Linux 命令行(中文版)</a></li><li><a href="http://works.jinbuguo.com/lfs/lfs62/index.html" target="_blank" rel="noopener">Linux 构建指南</a></li><li><a href="https://github.com/me115/linuxtools_rst" target="_blank" rel="noopener">Linux工具快速教程</a></li><li><a href="https://www.gitbook.com/book/tinylab/linux-doc/details" target="_blank" rel="noopener">Linux Documentation (中文版)</a></li><li><a href="https://www.gitbook.com/book/tinylab/elinux/details" target="_blank" rel="noopener">嵌入式 Linux 知识库 (eLinux.org 中文版)</a></li><li><a href="https://github.com/tobegit3hub/understand_linux_process" target="_blank" rel="noopener">理解Linux进程</a></li><li><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" rel="noopener">命令行的艺术</a></li><li><a href="https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/index.html" target="_blank" rel="noopener">SystemTap新手指南</a></li></ul><h3 id="智能系统"><a href="#智能系统" class="headerlink" title="智能系统"></a>智能系统</h3><ul><li><a href="https://github.com/phodal/designiot" target="_blank" rel="noopener">一步步搭建物联网系统</a></li></ul><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><ul><li><a href="http://dcaoyuan.github.io/papers/pdfs/Scalability.pdf" target="_blank" rel="noopener">走向分布式</a></li></ul><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul><li><a href="https://github.com/DeathKing/Learning-SICP" target="_blank" rel="noopener">《计算机程序的结构和解释》公开课 翻译项目</a></li></ul><h3 id="函数式概念"><a href="#函数式概念" class="headerlink" title="函数式概念"></a>函数式概念</h3><ul><li><a href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn" target="_blank" rel="noopener">傻瓜函数编程</a></li></ul><h3 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h3><ul><li><a href="https://github.com/zilongshanren/opengl-tutorials" target="_blank" rel="noopener">OpenGL 教程</a></li><li><p><a href="http://html5.iii.org.tw/course/webgl/" target="_blank" rel="noopener">WebGL自学网</a></p></li><li><p><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">Nginx开发从入门到精通</a> (淘宝团队出品)</p></li><li><a href="http://www.ttlsa.com/nginx/nginx-stu-pdf/" target="_blank" rel="noopener">ginx教程从入门到精通</a> (PDF版本，运维生存时间出品)</li><li><a href="https://www.gitbook.com/book/moonbingbing/openresty-best-practices/details" target="_blank" rel="noopener">OpenResty最佳实践</a></li><li><a href="http://works.jinbuguo.com/apache/menu22/index.html" target="_blank" rel="noopener">Apache 中文手册</a></li></ul><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ul><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git - 简易指南</a></li><li><a href="http://backlogtool.com/git-guide/cn/" target="_blank" rel="noopener">猴子都能懂的GIT入门</a></li><li><a href="http://gitref.justjavac.com/" target="_blank" rel="noopener">Git 参考手册</a></li><li><a href="http://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git</a></li><li><a href="https://www.gitbook.com/book/0532/progit/details" target="_blank" rel="noopener">Pro Git 中文版</a> (整理在gitbook上)</li><li><a href="http://www-cs-students.stanford.edu/%7Eblynn/gitmagic/intl/zh_cn/" target="_blank" rel="noopener">Git Magic</a></li><li><a href="http://www.worldhello.net/gotgithub/index.html" target="_blank" rel="noopener">GotGitHub</a></li><li><a href="http://www.worldhello.net/gotgit/" target="_blank" rel="noopener">Git权威指南</a></li><li><a href="http://gitbook.liuhui998.com/index.html" target="_blank" rel="noopener">Git Community Book 中文版</a></li><li><a href="https://www.mercurial-scm.org/wiki/ChineseTutorial" target="_blank" rel="noopener">Mercurial 使用教程</a></li><li><a href="http://bucunzai.net/hginit/" target="_blank" rel="noopener">HgInit (中文版)</a></li><li><a href="http://igit.linuxtoy.org" target="_blank" rel="noopener">沉浸式学 Git</a></li><li><a href="https://github.com/flyhigher139/Git-Cheat-Sheet" target="_blank" rel="noopener">Git-Cheat-Sheet</a></li><li><a href="https://snowdream86.gitbooks.io/github-cheat-sheet/content/zh/index.html" target="_blank" rel="noopener">GitHub秘籍</a></li><li><a href="https://github.com/waylau/github-help" target="_blank" rel="noopener">Github帮助文档</a></li><li><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="noopener">git-flow 备忘清单</a></li><li><a href="http://svnbook.red-bean.com/nightly/zh/index.html" target="_blank" rel="noopener">svn 手册</a></li><li><a href="https://github.com/phodal/github-roam" target="_blank" rel="noopener">GitHub漫游指南</a><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3></li><li><a href="https://github.com/vimcn/vimcdoc" target="_blank" rel="noopener">Vim中文文档</a></li><li><a href="https://github.com/yangyangwithgnu/use_vim_as_ide" target="_blank" rel="noopener">所需即所获：像 IDE 一样使用 vim</a></li><li><a href="https://github.com/wizardforcel/atom-flight-manual-zh-cn" target="_blank" rel="noopener">Atom飞行手册中文版</a></li><li><a href="https://github.com/wizardforcel/markdown-simple-world" target="_blank" rel="noopener">Markdown·简单的世界</a><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3></li><li><a href="http://yankaycom-wordpress.stor.sinaapp.com/NoSql_Database_Note.html?q=/wp-content/NoSql_Database_Note.html" target="_blank" rel="noopener">NoSQL数据库笔谈</a> (<a href="http://yankaycom-wordpress.stor.sinaapp.com/uploads/2012/12/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%B0%88v2.pdf" target="_blank" rel="noopener">PDF</a>)</li><li><a href="http://redisbook.com/" target="_blank" rel="noopener">Redis 设计与实现</a></li><li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a></li><li><a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="noopener">带有详细注释的 Redis 3.0 代码</a></li><li><a href="https://github.com/huangz1990/annotated_redis_source" target="_blank" rel="noopener">带有详细注释的 Redis 2.6 代码</a></li><li><a href="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md" target="_blank" rel="noopener">The Little MongoDB Book</a></li><li><a href="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md" target="_blank" rel="noopener">The Little Redis Book</a></li><li><a href="http://docs.neo4j.org.cn/" target="_blank" rel="noopener">Neo4j 简体中文手册 v1.8</a></li><li><a href="http://neo4j.tw/" target="_blank" rel="noopener">Neo4j .rb 中文資源</a></li><li><a href="http://disquebook.com" target="_blank" rel="noopener">Disque 使用教程</a><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h3></li><li><a href="http://works.jinbuguo.com/postgresql/menu823/index.html" target="_blank" rel="noopener">PostgreSQL 8.2.3 中文文档</a></li><li><a href="http://www.postgres.cn/docs/9.3/index.html" target="_blank" rel="noopener">PostgreSQL 9.3.1 中文文档</a><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></li><li><a href="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html" target="_blank" rel="noopener">21分钟MySQL入门教程</a><h3 id="管理监控"><a href="#管理监控" class="headerlink" title="管理监控"></a>管理监控</h3></li><li><a href="http://kibana.logstash.es" target="_blank" rel="noopener">ELKstack 中文指南</a></li><li><a href="http://udn.yyuap.com/doc/mastering-elasticsearch/" target="_blank" rel="noopener">Mastering Elasticsearch(中文版)</a></li><li><a href="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details" target="_blank" rel="noopener">ElasticSearch 权威指南</a></li><li><a href="http://es.xiaoleilu.com" target="_blank" rel="noopener">Elasticsearch 权威指南（中文版</a></li><li><a href="https://github.com/chenryn/logstash-best-practice-cn" target="_blank" rel="noopener">Logstash 最佳实践</a></li><li><a href="http://bbs.konotes.org/workdoc/puppet-27/" target="_blank" rel="noopener">Puppet 2.7 Cookbook 中文版</a><h3 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h3></li><li><a href="http://article.yeeyan.org/view/2251/94882" target="_blank" rel="noopener">持续集成（第二版） (译言网)</a></li><li><a href="http://www.ibm.com/developerworks/cn/java/j-ap/" target="_blank" rel="noopener">让开发自动化系列专栏</a></li><li><a href="http://www.ibm.com/developerworks/cn/java/j-cq/" target="_blank" rel="noopener">追求代码质量</a></li><li><a href="https://github.com/fool2fish/selenium-doc" target="_blank" rel="noopener">selenium 中文文档</a></li><li><a href="http://it-ebooks.flygon.net/selenium-simple-tutorial/" target="_blank" rel="noopener">Selenium Webdriver 简易教程</a></li><li><a href="http://local.joelonsoftware.com/wiki/%E9%A6%96%E9%A0%81" target="_blank" rel="noopener">約耳談軟體(Joel on Software)</a></li><li><a href="https://github.com/waylau/Gradle-2-User-Guide" target="_blank" rel="noopener">Gradle 2 用户指南</a></li><li><a href="http://yuedu.baidu.com/ebook/f23af265998fcc22bcd10da2" target="_blank" rel="noopener">Gradle 中文使用文档</a></li><li><a href="https://github.com/ecomfe/spec" target="_blank" rel="noopener">编码规范</a></li><li><a href="http://www.ituring.com.cn/book/1143" target="_blank" rel="noopener">开源软件架构</a></li><li><a href="http://docs.huihoo.com/gnu/linux/gmake.html" target="_blank" rel="noopener">GNU make 指南</a></li><li><a href="http://www.yayu.org/book/gnu_make/" target="_blank" rel="noopener">GNU make 中文手册</a><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3></li><li><a href="https://github.com/me115/design_patterns" target="_blank" rel="noopener">图说设计模式</a></li><li><a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="noopener">史上最全设计模式导学目录</a></li><li><a href="https://github.com/AlfredTheBest/Design-Pattern" target="_blank" rel="noopener">design pattern 包教不包会</a></li><li><a href="https://quanke.gitbooks.io/design-pattern-java/content/" target="_blank" rel="noopener">设计模式 Java 版</a><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3></li><li><a href="http://www.20thingsilearned.com/zh-CN/home" target="_blank" rel="noopener">关于浏览器和网络的 20 项须知</a></li><li><a href="http://jinlong.github.io/2013/08/29/devtoolsecrets/" target="_blank" rel="noopener">浏览器开发工具的秘密</a></li><li><a href="https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools" target="_blank" rel="noopener">Chrome 开发者工具中文手册</a></li><li><a href="http://open.chrome.360.cn/extension_dev/overview.html" target="_blank" rel="noopener">Chrome扩展开发文档</a></li><li><a href="http://www.gruntjs.net/" target="_blank" rel="noopener">Grunt中文文档</a></li><li><a href="http://www.gulpjs.com.cn/docs/" target="_blank" rel="noopener">gulp中文文档</a></li><li><a href="https://github.com/nimojs/gulp-book" target="_blank" rel="noopener">Gulp 入门指南</a></li><li><a href="https://github.com/AlloyTeam/Mars" target="_blank" rel="noopener">移动Web前端知识库</a></li><li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></li><li><a href="https://github.com/fouber/blog/issues/2" target="_blank" rel="noopener">前端开发体系建设日记</a></li><li><a href="https://github.com/hoosin/mobile-web-favorites" target="_blank" rel="noopener">移动前端开发收藏夹</a></li><li><a href="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md" target="_blank" rel="noopener">JSON风格指南</a></li><li><a href="https://github.com/bolasblack/http-api-guide" target="_blank" rel="noopener">HTTP 接口设计指北</a></li><li><a href="https://github.com/hacke2/hacke2.github.io/issues/1" target="_blank" rel="noopener">前端资源分享（一）</a></li><li><a href="https://github.com/hacke2/hacke2.github.io/issues/3" target="_blank" rel="noopener">前端资源分享（二）</a></li><li><a href="http://coderlmn.github.io/code-standards/" target="_blank" rel="noopener">前端代码规范 及 最佳实践</a></li><li><a href="https://www.gitbook.com/book/dwqs/frontenddevhandbook/details" target="_blank" rel="noopener">前端开发者手册</a></li><li><a href="https://www.gitbook.com/book/leohxj/front-end-database/details" target="_blank" rel="noopener">前端工程师手册</a></li><li><a href="https://github.com/wizardforcel/w3school" target="_blank" rel="noopener">w3school教程整理</a></li><li><a href="http://man.lupaworld.com/content/network/wireshark/index.html" target="_blank" rel="noopener">Wireshark用户手册</a></li><li><a href="https://community.emc.com/thread/194901" target="_blank" rel="noopener">一站式学习Wireshark</a></li><li><a href="http://happypeter.github.io/tealeaf-http/" target="_blank" rel="noopener">HTTP 下午茶</a></li><li><a href="http://yuedu.baidu.com/ebook/478d1a62376baf1ffc4fad99?pn=1" target="_blank" rel="noopener">HTTP/2.0 中文翻译</a></li><li><a href="https://github.com/abbshr/rfc7540-translation-zh_cn" target="_blank" rel="noopener">RFC 7540 - HTTP/2 中文翻译版</a></li><li><a href="https://www.gitbook.com/book/ye11ow/http2-explained/details" target="_blank" rel="noopener">http2讲解</a></li><li><a href="https://www.gitbook.com/book/juntao/3-web-designs-in-3-weeks/details" target="_blank" rel="noopener">3 Web Designs in 3 Weeks</a><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3></li><li><a href="https://github.com/Flowerowl/Big-Data-Resources" target="_blank" rel="noopener">大数据/数据挖掘/推荐系统/机器学习相关资源</a></li><li><a href="https://github.com/egrcc/guidetodatamining" target="_blank" rel="noopener">面向程序员的数据挖掘指</a></li><li><a href="https://code.csdn.net/CODE_Translation/spark_matei_phd" target="_blank" rel="noopener">大型集群上的快速和通用数据处理架构</a></li><li><a href="https://github.com/linyiqun/DataMiningAlgorithm" target="_blank" rel="noopener">数据挖掘中经典的算法实现和详细的注释</a></li><li><a href="https://aiyanbo.gitbooks.io/spark-programming-guide-zh-cn/content/" target="_blank" rel="noopener">Spark 编程指南简体中文版</a><h3 id="编程艺术"><a href="#编程艺术" class="headerlink" title="编程艺术"></a>编程艺术</h3></li><li><a href="https://github.com/julycoding/The-Art-Of-Programming-by-July" target="_blank" rel="noopener">程序员编程艺术</a></li><li><a href="http://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1?print" target="_blank" rel="noopener">每个程序员都应该了解的内存知识(译)</a></li><li><a href="http://read.douban.com/ebook/4972883/" target="_blank" rel="noopener">取悦的工序：如何理解游戏</a><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3></li><li><a href="https://www.gitbook.com/book/softwaredownload/openwrt-fanqiang/details" target="_blank" rel="noopener">OpenWrt智能、自动、透明翻墙路由器教程</a></li><li><a href="https://community.emc.com/docs/DOC-16067" target="_blank" rel="noopener">SAN 管理入门系列</a></li><li><a href="http://sketchcn.com/sketch-chinese-user-manual.html#introduce" target="_blank" rel="noopener">Sketch 中文手册</a></li><li><a href="http://ifeve.com/perfbook/" target="_blank" rel="noopener">深入理解并行编程</a></li><li><a href="http://www.kancloud.cn/kancloud/a-programmer-prepares" target="_blank" rel="noopener">程序员的自我修养</a></li><li><a href="https://github.com/phodal/growth-ebook" target="_blank" rel="noopener">Growth: 全栈增长工程师指南</a><h2 id="语言相关类"><a href="#语言相关类" class="headerlink" title="语言相关类"></a>语言相关类</h2><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3></li><li><a href="http://www.apkbus.com/design/index.html" target="_blank" rel="noopener">awk程序设计语言</a></li><li>Google Material Design 正體中文版  <a href="https://wcc723.gitbooks.io/google_design_translate/content/style-icons.html" target="_blank" rel="noopener">译本一</a>  <a href="https://github.com/1sters/material_design_zh" target="_blank" rel="noopener">译本二</a></li><li><a href="http://wiki.jikexueyuan.com/project/material-design/" target="_blank" rel="noopener">Material Design 中文版</a></li><li><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="noopener">Google Android官方培训课程中文版</a></li><li><a href="http://www.stormzhang.com/android/2014/07/07/learn-android-from-rookie" target="_blank" rel="noopener">Android学习之路</a></li><li><a href="https://github.com/bboyfeiyu/android-tech-frontier" target="_blank" rel="noopener">Android开发技术前线(android-tech-frontier)</a></li><li><a href="https://github.com/FX-Max/Point-of-Android" target="_blank" rel="noopener">Point-of-AndroidAndroid 一些重要知识点解析整理</a></li><li><a href="http://leanote.com/blog/post/561658f938f41126b2000298?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">Android6.0新特性详解</a><h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3></li><li><a href="https://github.com/waylau/cordova-dev-guide" target="_blank" rel="noopener">Apache Cordova 开发指南</a><h3 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h3></li><li><a href="https://github.com/wuzhouhui/awk" target="_blank" rel="noopener">awk程序设计语言</a></li><li><a href="http://awk.readthedocs.org/en/latest/index.html" target="_blank" rel="noopener">awk中文指南</a><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3></li><li><a href="http://zh.cppreference.com/" target="_blank" rel="noopener">C/C++ 中文参考手册 (欢迎大家参与在线翻译和校对)</a></li><li><a href="https://www.gitbook.com/book/tinylab/cbook/details" target="_blank" rel="noopener">C 语言编程透视</a></li><li><a href="https://github.com/forhappy/Cplusplus-Concurrency-In-Practice" target="_blank" rel="noopener">C++ 并发编程指南</a></li><li><a href="http://akaedu.github.io/book/" target="_blank" rel="noopener">Linux C编程一站式学习 (宋劲杉, 北京亚嵌教育研究中心)</a></li><li><a href="https://github.com/leeyiw/cgdb-manual-in-chinese" target="_blank" rel="noopener">CGDB中文手册</a></li><li><a href="https://github.com/hellogcc/100-gdb-tips/blob/master/src/index.md" target="_blank" rel="noopener">100个gdb小技巧</a></li><li><a href="https://github.com/hellogcc/100-gcc-tips/blob/master/src/index.md" target="_blank" rel="noopener">100个gcc小技巧</a></li><li><a href="https://github.com/anjuke/zguide-cn" target="_blank" rel="noopener">ZMQ 指南</a></li><li><a href="http://www.ituring.com.cn/book/1203" target="_blank" rel="noopener">How to Think Like a Computer Scientist (中英文版)</a></li><li><a href="http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf" target="_blank" rel="noopener">跟我一起写Makefile(PDF)</a></li><li><a href="http://www.yayu.org/book/gnu_make/" target="_blank" rel="noopener">GNU make中文手册</a></li><li><a href="http://docs.huihoo.com/gnu/linux/gmake.html" target="_blank" rel="noopener">GNU make 指南</a></li><li><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">Google C++ 风格指南</a></li><li><a href="https://github.com/andycai/cprimer" target="_blank" rel="noopener">C/C++ Primer</a></li><li><a href="http://www.nowamagic.net/librarys/books/contents/c" target="_blank" rel="noopener">简单易懂的C魔法</a></li><li><a href="http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf" target="_blank" rel="noopener">Cmake 实践 (PDF版)</a></li><li><a href="http://www.sunistudio.com/cppfaq/" target="_blank" rel="noopener">C++ FAQ LITE(中文版)</a></li><li><a href="https://github.com/Mooophy/Cpp-Primer" target="_blank" rel="noopener">C++ Primer 5th Answers</a></li><li><a href="https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details" target="_blank" rel="noopener">C++ 并发编程(基于C++11)</a></li><li><a href="http://www.kuqin.com/qtdocument/tutorial.html" target="_blank" rel="noopener">QT 教程</a></li><li><a href="http://www.devbean.net/category/qt-study-road-2/" target="_blank" rel="noopener">DevBean的《Qt学习之路2》(Qt5)</a></li><li><a href="https://github.com/wuye9036/CppTemplateTutorial" target="_blank" rel="noopener">C++ Template 进阶指南</a></li><li><a href="https://github.com/luohaha/Chinese-uvbook" target="_blank" rel="noopener">libuv中文教程</a></li><li><a href="http://zh.highscore.de/cpp/boost/" target="_blank" rel="noopener">Boost 库中文教程</a><h3 id="Clojure"><a href="#Clojure" class="headerlink" title="Clojure"></a>Clojure</h3></li><li><a href="http://xumingming.sinaapp.com/302/clojure-functional-programming-for-the-jvm-clojure-tutorial/" target="_blank" rel="noopener">Clojure入门教程</a><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3></li><li><a href="https://msdn.microsoft.com/zh-cn/library/kx37x362.aspx" target="_blank" rel="noopener">MSDN C# 中文文档</a></li><li><a href="https://msdn.microsoft.com/zh-cn/library/gg145045.aspx" target="_blank" rel="noopener">.NET 类库参考</a></li><li><a href="http://www.cnblogs.com/powertoolsteam/p/aspnetmvc5-tutorials-grapecity.html" target="_blank" rel="noopener">ASP.NET MVC 5 入门指南</a></li><li><a href="http://www.cnblogs.com/LonelyShadow/p/4162318.html" target="_blank" rel="noopener">超全面的 .NET GDI+ 图形图像编程教程</a></li><li><a href="https://github.com/JackWangCUMT/customcontrol" target="_blank" rel="noopener">.NET控件开发基础</a><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3></li><li><a href="http://zh.learnlayout.com/" target="_blank" rel="noopener">学习CSS布局</a></li><li><a href="https://github.com/chadluo/CSS-Guidelines/blob/master/README.md" target="_blank" rel="noopener">通用 CSS 笔记、建议与指导</a></li><li><a href="http://css.doyoe.com/" target="_blank" rel="noopener">CSS参考手册</a></li><li><a href="http://yanxyz.github.io/emmet-docs/" target="_blank" rel="noopener">Emmet 文档</a></li><li><a href="http://alloyteam.github.io/CodeGuide/" target="_blank" rel="noopener">前端代码规范 (腾讯 AlloyTeam 团队)</a></li><li><a href="http://codeguide.bootcss.com/" target="_blank" rel="noopener">HTML和CSS编码规范</a></li><li><a href="http://sass-guidelin.es/zh/" target="_blank" rel="noopener">Sass Guidelines 中文</a></li><li><a href="https://github.com/waylau/css3-tutorial" target="_blank" rel="noopener">CSS3 Tutorial 《CSS3 教程》</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" target="_blank" rel="noopener">MDN HTML 中文文档</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN CSS 中文文档</a><h3 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h3></li><li><a href="http://dart.lidian.info/wiki/Language_Tour" target="_blank" rel="noopener">Dart 语言导览</a><h3 id="Elixir"><a href="#Elixir" class="headerlink" title="Elixir"></a>Elixir</h3></li><li><a href="https://github.com/straightdave/programming_elixir" target="_blank" rel="noopener">Elixir编程入门</a><h3 id="Erlang"><a href="#Erlang" class="headerlink" title="Erlang"></a>Erlang</h3></li><li><a href="http://xn--21erlang-p00o82pmp3o.github.io/" target="_blank" rel="noopener">21天学通Erlang</a><h3 id="Fortran"><a href="#Fortran" class="headerlink" title="Fortran"></a>Fortran</h3></li><li><a href="http://micro.ustc.edu.cn/Fortran/ZJDing/" target="_blank" rel="noopener">Fortran77和90/95编程入门</a><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3></li><li><a href="https://github.com/Unknwon/go-fundamental-programming" target="_blank" rel="noopener">Go编程基础</a></li><li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN" target="_blank" rel="noopener">Go入门指南</a></li><li><a href="http://mikespook.com/learning-go/" target="_blank" rel="noopener">学习Go语言</a></li><li><a href="https://github.com/astaxie/build-web-application-with-golang" target="_blank" rel="noopener">Go Web 编程</a></li><li><a href="https://github.com/astaxie/Go-in-Action" target="_blank" rel="noopener">Go实战开发</a></li><li><a href="https://github.com/astaxie/NPWG_zh" target="_blank" rel="noopener">Network programming with Go 中文翻译版本</a></li><li><a href="http://www.hellogcc.org/effective_go.html" target="_blank" rel="noopener">Effective Go</a></li><li><a href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example" target="_blank" rel="noopener">Go 语言标准库</a></li><li><a href="http://gorevel.cn/docs/manual/index.html" target="_blank" rel="noopener">Revel 框架手册</a></li><li><a href="http://blog.csdn.net/dc_726/article/details/46565241" target="_blank" rel="noopener">Java程序员的Golang入门指南</a></li><li><a href="https://github.com/hyper-carrot/go_command_tutorial" target="_blank" rel="noopener">Go命令教程</a></li><li><a href="https://github.com/achun/Go-Blog-In-Action" target="_blank" rel="noopener">Go语言博客实践</a></li><li><a href="https://github.com/golang-china/golangdoc.translations" target="_blank" rel="noopener">Go 官方文档翻译</a></li><li><a href="https://github.com/tiancaiamao/go-internals" target="_blank" rel="noopener">深入解析Go</a></li><li><a href="https://bitbucket.org/golang-china/gopl-zh/wiki/Home" target="_blank" rel="noopener">Go语言圣经(中文版)</a><h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3></li><li><a href="http://www.ibm.com/developerworks/cn/java/j-pg/" target="_blank" rel="noopener">实战 Groovy 系列</a><h3 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h3></li><li><a href="http://rwh.readthedocs.org/en/latest/" target="_blank" rel="noopener">Real World Haskell 中文版</a></li><li><a href="http://fleurer-lee.com/lyah/" target="_blank" rel="noopener">Haskell趣学指南</a><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3></li><li><a href="https://github.com/qinjx/30min_guides/blob/master/ios.md" target="_blank" rel="noopener">iOS开发60分钟入门</a></li><li><a href="http://isux.tencent.com/ios-human-interface-guidelines-ui-design-basics-ios7.html" target="_blank" rel="noopener">iOS7人机界面指南</a></li><li><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/" target="_blank" rel="noopener">Google Objective-C Style Guide 中文版</a></li><li><a href="http://wileam.com/iphone-6-screen-cn/" target="_blank" rel="noopener">iPhone 6 屏幕揭秘</a></li><li><a href="http://nilsun.github.io/apple-watch/" target="_blank" rel="noopener">Apple Watch开发初探</a></li><li><a href="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/index.html" target="_blank" rel="noopener">马上着手开发 iOS 应用程序</a></li><li><a href="https://github.com/jkyin/Subtitle" target="_blank" rel="noopener">网易斯坦福大学公开课：iOS 7应用开发字幕文件</a><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3></li><li><a href="https://github.com/waylau/apache-shiro-1.2.x-reference" target="_blank" rel="noopener">Apache Shiro 用户指南</a></li><li><a href="https://github.com/waylau/Jersey-2.x-User-Guide" target="_blank" rel="noopener">Jersey 2.x 用户指南</a></li><li><a href="https://github.com/waylau/spring-framework-4-reference" target="_blank" rel="noopener">Spring Framework 4.x参考文档</a></li><li><a href="https://github.com/qibaoguang/Spring-Boot-Reference-Guide" target="_blank" rel="noopener">Spring Boot参考指南(翻译中)</a></li><li><a href="http://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">MyBatis中文文档</a></li><li><a href="http://mbg.cndocs.tk/" target="_blank" rel="noopener">MyBatis Generator 中文文档</a></li><li><a href="https://github.com/waylau/RestDemo" target="_blank" rel="noopener">用jersey构建REST服务</a></li><li><a href="https://github.com/waylau/activiti-5.x-user-guide" target="_blank" rel="noopener">Activiti 5.x 用户指</a></li><li><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">Google Java编程风格指南</a></li><li><a href="https://github.com/waylau/netty-4-user-guide" target="_blank" rel="noopener">Netty 4.x 用户指南</a></li><li><a href="https://github.com/waylau/essential-netty-in-action" target="_blank" rel="noopener">Netty 实战(精髓)</a></li><li><a href="https://github.com/waylau/rest-in-action" target="_blank" rel="noopener">REST 实战</a></li><li><a href="https://github.com/waylau/java-code-conventions" target="_blank" rel="noopener">Java 编码规范</a></li><li><a href="https://github.com/waylau/apache-mina-2.x-user-guide" target="_blank" rel="noopener">Apache MINA 2 用户指南</a></li><li><a href="https://github.com/waylau/h2-database-doc" target="_blank" rel="noopener">H2 Database 教程</a></li><li><a href="https://github.com/waylau/servlet-3.1-specification" target="_blank" rel="noopener">Java Servlet 3.1 规范</a></li><li><a href="https://github.com/waylau/jsse-reference-guide" target="_blank" rel="noopener">JSSE 参考指南</a></li><li><a href="https://github.com/biezhi/jb" target="_blank" rel="noopener">Java开源实现及最佳实践</a></li><li><a href="https://github.com/waylau/essential-java" target="_blank" rel="noopener">Java 编程要点</a></li><li><a href="http://www.ituring.com.cn/minibook/69" target="_blank" rel="noopener">Think Java</a><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3></li><li><a href="http://bq69.com/blog/articles/script/868/google-javascript-style-guide.html" target="_blank" rel="noopener">Google JavaScript 代码风格指南</a></li><li><a href="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md" target="_blank" rel="noopener">Google JSON 风格指南</a></li><li><a href="https://github.com/adamlu/javascript-style-guide" target="_blank" rel="noopener">Airbnb JavaScript 规范</a></li><li><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">JavaScript 标准参考教程（alpha）</a></li><li><a href="http://pij.robinqu.me/" target="_blank" rel="noopener">Javascript编程指南</a> <a href="https://github.com/RobinQu/Programing-In-Javascript" target="_blank" rel="noopener">(源码)</a></li><li><a href="https://github.com/justjavac/12-javascript-quirks" target="_blank" rel="noopener">javascript 的 12 个怪癖</a></li><li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="noopener">JavaScript 秘密花园</a></li><li><a href="http://icodeit.org/jsccp/" target="_blank" rel="noopener">JavaScript核心概念及实践</a></li><li><a href="https://github.com/jayli/javascript-patterns" target="_blank" rel="noopener">《JavaScript 模式》“JavaScript patterns”中译本</a></li><li><a href="http://justjavac.com/named-function-expressions-demystified.html" target="_blank" rel="noopener">命名函数表达式探秘</a></li><li><a href="http://www.oschina.net/translate/learning-javascript-design-patterns" target="_blank" rel="noopener">学用 JavaScript 设计模式 (开源中国)</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">深入理解JavaScript系列</a></li><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门 (作者：阮一峰)</a></li><li><a href="http://liubin.github.io/promises-book/" target="_blank" rel="noopener">JavaScript Promise迷你书</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="noopener">You-Dont-Know-JS(深入JavaScript语言核心机制的系列图书)</a></li><li><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">JavaScript 教程廖雪峰</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">MDN JavaScript 中文文档</a></li><li>jQuery<ul><li><a href="http://www.cn-cuckoo.com/deconstructed/jquery.html" target="_blank" rel="noopener">jQuery 解构</a></li><li><a href="http://www.nowamagic.net/librarys/books/contents/jquery" target="_blank" rel="noopener">简单易懂的JQuery魔法</a></li><li><a href="http://i5ting.github.io/How-to-write-jQuery-plugin/build/jquery.plugin.html" target="_blank" rel="noopener">How to write jQuery plugin</a></li><li><a href="https://github.com/oneuijs/You-Dont-Need-jQuery/blob/master/README.zh-CN.md" target="_blank" rel="noopener">You Don’t Need jQuery</a></li><li><a href="https://github.com/MeCKodo/forchange" target="_blank" rel="noopener">如何实现一个类jQuery</a></li></ul></li><li>Node.js<ul><li><a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">Node入门</a></li><li><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="noopener">七天学会NodeJS</a></li><li><a href="https://github.com/nodejs-tw/nodejs-wiki-book" target="_blank" rel="noopener">Nodejs Wiki Book (繁体中文)</a></li><li><a href="http://expressjs.jser.us/" target="_blank" rel="noopener">express.js 中文文档</a></li><li><a href="https://github.com/guo-yu/koa-guide" target="_blank" rel="noopener">koa 中文文档</a></li><li><a href="http://base-n.github.io/koa-generator-examples/" target="_blank" rel="noopener">一起学koa</a></li><li><a href="https://github.com/nswbmw/N-blog" target="_blank" rel="noopener">使用 Express + MongoDB 搭建多人博客</a></li><li><a href="http://javascript.ruanyifeng.com/nodejs/express.html" target="_blank" rel="noopener">Express框架</a></li><li><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="noopener">Node.js 包教不包会</a></li><li><a href="https://www.npmjs.com/package/learnyounode-zh-cn" target="_blank" rel="noopener">Learn You The Node.js For Much Win! (中文版)</a></li><li><a href="http://i5ting.github.io/node-debug-tutorial/" target="_blank" rel="noopener">Node debug 三法三例</a></li><li><a href="https://www.gitbook.com/book/0532/nodejs/details" target="_blank" rel="noopener">nodejs中文文档</a></li><li><a href="https://github.com/wizardforcel/orm2-doc-zh-cn" target="_blank" rel="noopener">orm2 中文文档</a></li></ul></li><li>underscore.js<ul><li><a href="http://learningcn.com/underscore/" target="_blank" rel="noopener">Underscore.js中文文档</a></li></ul></li><li>backbone.js<ul><li><a href="http://www.css88.com/doc/backbone/" target="_blank" rel="noopener">backbone.js中文文档</a></li><li><a href="http://www.the5fire.com/backbone-js-tutorials-pdf-download.html" target="_blank" rel="noopener">backbone.js入门教程 (PDF)</a></li><li><a href="https://github.com/the5fire/backbonejs-learning-note" target="_blank" rel="noopener">Backbone.js入门教程第二版</a></li><li><a href="http://feliving.github.io/developing-backbone-applications/" target="_blank" rel="noopener">Developing Backbone.js Applications(中文版)</a></li></ul></li><li>AngularJS<ul><li><a href="https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md" target="_blank" rel="noopener">AngularJS最佳实践和风格指南</a></li><li><a href="https://github.com/peiransun/angularjs-cn" target="_blank" rel="noopener">AngularJS中译本</a></li><li><a href="https://github.com/zensh/AngularjsTutorial_cn" target="_blank" rel="noopener">AngularJS入门教程</a></li><li><a href="https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md" target="_blank" rel="noopener">构建自己的AngularJS</a></li><li><a href="http://www.waylau.com/build-angularjs-app-with-yeoman-in-windows/" target="_blank" rel="noopener">在Windows环境下用Yeoman构建AngularJS项目</a></li></ul></li><li>zepto.js<ul><li><a href="http://mweb.baidu.com/zeptoapi/" target="_blank" rel="noopener">Zepto.js 中文文档</a></li></ul></li><li>Sea.js<ul><li><a href="http://island205.com/HelloSea.js/" target="_blank" rel="noopener">Hello Sea.js</a></li></ul></li><li>React.js<ul><li><a href="http://reactjs.cn/" target="_blank" rel="noopener">React.js 中文文档</a></li><li><a href="https://github.com/fakefish/react-webpack-cookbook" target="_blank" rel="noopener">React webpack-cookbook</a></li><li><a href="http://fraserxu.me/intro-to-react/" target="_blank" rel="noopener">React 入门教程</a></li><li><a href="http://wiki.jikexueyuan.com/project/react-native/" target="_blank" rel="noopener">React Native 中文文档(含最新Android内容)</a></li><li><a href="https://github.com/theJian/build-a-hn-front-page" target="_blank" rel="noopener">Learn React &amp; Webpack by building the Hacker News front page</a></li></ul></li><li>impress.js<ul><li><a href="https://github.com/kokdemo/impress.js-tutorial-in-Chinese" target="_blank" rel="noopener">impress.js的中文教程</a></li></ul></li><li>CoffeeScript<ul><li><a href="http://island205.com/coffeescript-cookbook.github.com/" target="_blank" rel="noopener">CoffeeScript Cookbook</a></li><li><a href="http://island205.com/tlboc/" target="_blank" rel="noopener">The Little Book on CoffeeScript中文版</a></li><li><a href="https://github.com/geekplux/coffeescript-style-guide" target="_blank" rel="noopener">CoffeeScript 编码风格指南</a></li></ul></li><li>TypeScipt<ul><li><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/" target="_blank" rel="noopener">TypeScript Handbook</a></li></ul></li><li>ExtJS<ul><li><a href="http://extjs-doc-cn.github.io/ext4api/" target="_blank" rel="noopener">Ext4.1.0 中文文档</a></li></ul></li><li>Meteor<ul><li><a href="http://zh.discovermeteor.com/" target="_blank" rel="noopener">Discover Meteor</a></li><li><a href="http://docs.meteorhub.org/#/basic/" target="_blank" rel="noopener">Meteor 中文文档</a></li><li><a href="http://angular.meteorhub.org/" target="_blank" rel="noopener">Angular-Meteor 中文教程</a></li></ul></li><li><a href="http://www.ituring.com.cn/minibook/950" target="_blank" rel="noopener">Chrome扩展及应用开发</a><h3 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h3></li><li><a href="http://liam0205.me/2014/09/08/latex-introduction/" target="_blank" rel="noopener">一份其实很短的 LaTeX 入门文档</a></li><li><a href="http://www.mohu.org/info/lshort-cn.pdf" target="_blank" rel="noopener">一份不太简短的 LATEX 2ε 介绍（PDF版）</a><h3 id="LISP"><a href="#LISP" class="headerlink" title="LISP"></a>LISP</h3></li><li><a href="http://acl.readthedocs.org/en/latest/" target="_blank" rel="noopener">ANSI Common Lisp 中文翻譯版</a></li><li><a href="http://www.ituring.com.cn/minibook/862" target="_blank" rel="noopener">On Lisp 中文翻译版</a></li><li><a href="http://deathking.github.io/yast-cn/" target="_blank" rel="noopener">Yet Another Scheme Tutorial Scheme入门教程</a></li><li><a href="http://songjinghe.github.io/TYS-zh-translation/" target="_blank" rel="noopener">Scheme语言简明教程</a></li><li><a href="https://github.com/tyrchen/racket-book" target="_blank" rel="noopener">Racket book</a><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3></li><li><a href="https://github.com/andycai/luaprimer" target="_blank" rel="noopener">Lua编程入门</a></li><li><a href="http://www.codingnow.com/2000/download/lua_manual.html" target="_blank" rel="noopener">Lua 5.1 参考手册 中文翻译</a></li><li><a href="http://cloudwu.github.io/lua53doc/" target="_blank" rel="noopener">Lua 5.3 参考手册 中文翻译</a></li><li><a href="http://www.codingnow.com/temp/readinglua.pdf" target="_blank" rel="noopener">Lua源码欣赏</a><h3 id="OCaml"><a href="#OCaml" class="headerlink" title="OCaml"></a>OCaml</h3></li><li><a href="https://github.com/zforget/translation/tree/master/real_world_ocaml" target="_blank" rel="noopener">Real World OCaml</a><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3></li><li><a href="https://github.com/horus/modern_perl_book" target="_blank" rel="noopener">Modern Perl 中文版</a></li><li><a href="http://perl.linuxtoy.org/" target="_blank" rel="noopener">Perl 程序员应该知道的事</a><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3></li><li><a href="http://php.net/manual/zh/" target="_blank" rel="noopener">PHP 官方手册</a></li><li><a href="http://www.laruence.com/2010/06/21/1608.html" target="_blank" rel="noopener">PHP调试技术手册(PDF)</a></li><li><a href="http://wulijun.github.io/php-the-right-way/" target="_blank" rel="noopener">PHP之道：php-the-right-way</a></li><li><a href="https://github.com/justjavac/PHP-Best-Practices-zh_CN" target="_blank" rel="noopener">PHP 最佳实践</a></li><li><a href="https://ryancao.gitbooks.io/php-developer-prepares/content/" target="_blank" rel="noopener">PHP 开发者实践</a></li><li><a href="https://github.com/reeze/tipi" target="_blank" rel="noopener">深入理解PHP内核</a></li><li><a href="http://www.walu.cc/phpbook/" target="_blank" rel="noopener">PHP扩展开发及内核应用</a></li><li><a href="http://codeigniter.org.cn/user_guide/index.html" target="_blank" rel="noopener">CodeIgniter 用户指南</a></li><li><a href="http://www.golaravel.com/laravel/docs/5.0/" target="_blank" rel="noopener">Laravel5 中文文档</a></li><li><a href="https://github.com/huanghua581/laravel-getting-started" target="_blank" rel="noopener">Laravel 入门</a></li><li><a href="http://yiibook.com//doc" target="_blank" rel="noopener">YiiBook几本Yii框架的在线教程</a></li><li><a href="http://www.digpage.com/" target="_blank" rel="noopener">深入理解 Yii 2.0</a></li><li><a href="http://www.yiichina.com/" target="_blank" rel="noopener">Yii 框架中文文檔</a></li><li><a href="http://www.nowamagic.net/librarys/books/contents/php" target="_blank" rel="noopener">简单易懂的PHP魔法</a></li><li><a href="https://github.com/LinkedDestiny/swoole-doc" target="_blank" rel="noopener">swoole文档及入门教程</a></li><li><a href="http://www.phpcomposer.com/" target="_blank" rel="noopener">Composer 中文网</a></li><li><a href="http://ww1.minimee.org/php/slim" target="_blank" rel="noopener">Slim 中文文档</a></li><li><a href="http://lumen.laravel-china.org/" target="_blank" rel="noopener">Lumen 中文文档</a></li><li><a href="https://phpunit.de/manual/current/zh_cn/installation.html" target="_blank" rel="noopener">PHPUnit 中文文档</a><h3 id="Prolog"><a href="#Prolog" class="headerlink" title="Prolog"></a>Prolog</h3></li><li><a href="http://fengdidi.github.io/blog/2011/11/15/qian-yan/" target="_blank" rel="noopener">笨办法学Prolog</a><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3></li><li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="noopener">廖雪峰 Python 2.7 中文教程</a></li><li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰 Python 3 中文教程</a></li><li><a href="http://www.kuqin.com/abyteofpython_cn/" target="_blank" rel="noopener">简明Python教程</a></li><li><a href="http://www.kancloud.cn/kancloud/python-basic" target="_blank" rel="noopener">零基础学 Python 第一版</a></li><li><a href="http://www.kancloud.cn/kancloud/starter-learning-python" target="_blank" rel="noopener">零基础学 Python 第二版</a></li><li><a href="http://lovelypython.readthedocs.org/en/latest/" target="_blank" rel="noopener">可爱的 Python</a></li><li><a href="http://www.pythondoc.com/pythontutorial27/index.html" target="_blank" rel="noopener">Python 2.7 官方教程中文版</a></li><li><a href="http://www.pythondoc.com/pythontutorial3/index.html" target="_blank" rel="noopener">Python 3.3 官方教程中文版</a></li><li><a href="http://www.kancloud.cn/thinkphp/python-cookbook" target="_blank" rel="noopener">Python Cookbook 中文版</a></li><li><a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">Python3 Cookbook 中文版</a></li><li><a href="http://www.kuqin.com/docs/diveintopythonzh-cn-5.4b/html/toc/" target="_blank" rel="noopener">深入 Python</a></li><li><a href="http://old.sebug.net/paper/books/dive-into-python3/" target="_blank" rel="noopener">深入 Python 3</a></li><li><a href="https://code.google.com/p/zhong-wiki/wiki/PEP8" target="_blank" rel="noopener">PEP8 Python代码风格规范</a></li><li><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-python-styleguide/" target="_blank" rel="noopener">Google Python 风格指南 中文版</a></li><li><a href="http://liam0205.me/2013/11/02/Python-tutorial-zh_cn/" target="_blank" rel="noopener">Python入门教程</a> <a href="http://liam0205.me/attachment/Python/The_Python_Tutorial_zh-cn.pdf" target="_blank" rel="noopener">(PDF)</a></li><li><a href="http://article.yeeyan.org/view/311527/287706" target="_blank" rel="noopener">Python的神奇方法指南</a></li><li><a href="http://old.sebug.net/paper/books/LearnPythonTheHardWay/" target="_blank" rel="noopener">笨办法学 Python</a></li><li><a href="http://pan.baidu.com/s/1qW4pvnY" target="_blank" rel="noopener">Python自然语言处理中文版</a></li><li><a href="http://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/" target="_blank" rel="noopener">Python 绘图库 matplotlib 官方指南中文翻译</a></li><li><a href="http://scrapy-chs.readthedocs.org/zh_CN/latest/" target="_blank" rel="noopener">Scrapy 0.25 文档</a></li><li><a href="https://github.com/carfly/thinkpython-cn" target="_blank" rel="noopener">ThinkPython</a></li><li><a href="https://github.com/bingjin/ThinkPython2-CN" target="_blank" rel="noopener">ThinkPython 2ed</a></li><li><a href="http://www.cnblogs.com/vamei/archive/2012/09/13/2682778.html" target="_blank" rel="noopener">Python快速教程</a></li><li><a href="http://wiki.ubuntu.org.cn/Python正则表达式操作指南" target="_blank" rel="noopener">Python 正则表达式操作指南</a></li><li><a href="http://www.crifan.com/files/doc/docbook/python_beginner_tutorial/release/html/python_beginner_tutorial.html" target="_blank" rel="noopener">python初级教程：入门详解</a></li><li><a href="https://www.gitbook.com/book/likebeta/twisted-intro-cn/details" target="_blank" rel="noopener">Twisted 与异步编程入门</a></li><li><a href="http://textgrocery.readthedocs.org/zh/latest/index.html" target="_blank" rel="noopener">TextGrocery 中文 API( 基于svm算法的一个短文本分类 Python 库 )</a></li><li><a href="http://requests-docs-cn.readthedocs.org/zh_CN/latest/" target="_blank" rel="noopener">Requests: HTTP for Humans</a></li><li><a href="http://pillow-cn.readthedocs.org/en/latest/#" target="_blank" rel="noopener">Pillow 中文文档</a></li><li><a href="http://pymotwcn.readthedocs.org/en/latest/index.html" target="_blank" rel="noopener">PyMOTW 中文版</a></li><li><a href="http://data.digitser.net/zh-CN/python_index.html" target="_blank" rel="noopener">Python 官方文档中文版</a></li><li><a href="http://fabric-chs.readthedocs.org" target="_blank" rel="noopener">Fabric 中文文档</a></li><li><a href="http://beautifulsoup.readthedocs.org/zh_CN/latest/" target="_blank" rel="noopener">Beautiful Soup 4.2.0 中文文档</a></li><li><a href="http://old.sebug.net/paper/books/scipydoc" target="_blank" rel="noopener">用Python做科学计算</a></li><li><a href="http://www.pythondoc.com/sphinx/index.html" target="_blank" rel="noopener">Sphinx 中文文档</a></li><li><a href="https://github.com/cundi/Mastering.Python.Design.Patterns" target="_blank" rel="noopener">精通 Python 设计模式</a></li><li><a href="https://github.com/smartFlash/pySecurity" target="_blank" rel="noopener">python 安全编程教程</a></li><li><a href="https://www.gitbook.com/book/wizardforcel/sjtu-cs902-courseware/details" target="_blank" rel="noopener">程序设计思想与方法</a></li><li><a href="https://read.douban.com/ebook/16691849/" target="_blank" rel="noopener">知乎周刊·编程小白学Python</a></li><li><a href="https://github.com/cloga/scipy-lecture-notes_cn" target="_blank" rel="noopener">Scipy 讲义</a></li><li><a href="http://www.kuqin.com/docs/pythonbasic.html" target="_blank" rel="noopener">Python 学习笔记 基础篇</a></li><li><a href="http://www.kuqin.com/docs/pythonmodule.html" target="_blank" rel="noopener">Python 学习笔记 模块篇</a></li><li><a href="http://old.sebug.net/paper/books/python/%E3%80%8APython%E6%A0%87%E5%87%86%E5%BA%93%E3%80%8B%E4%B8%AD%E6%96%87%E7%89%88.pdf" target="_blank" rel="noopener">Python 标准库 中文版</a></li><li><a href="https://www.gitbook.com/book/eastlakeside/interpy-zh/details" target="_blank" rel="noopener">Python进阶</a></li><li><a href="http://openbookproject.googlecode.com/svn/trunk/CorePython_zh/" target="_blank" rel="noopener">Python 核心编程 第二版 CPyUG译</a></li><li>Django<ul><li><a href="http://django-chinese-docs.readthedocs.org/en/latest/" target="_blank" rel="noopener">Django 1.5 文档中文版 正在翻译中</a></li><li><a href="http://django-1-7-doc.coding.io/" target="_blank" rel="noopener">Diango 1.7 文档中文版 正在翻译中，目前只翻译了目录</a></li><li><a href="http://python.usyiyi.cn/django/index.html" target="_blank" rel="noopener">Django 1.8.2 文档中文版 正在翻译中</a></li><li><a href="https://github.com/yangyubo/zh-django-best-practices" target="_blank" rel="noopener">Django 最佳实践</a></li><li><a href="https://www.gitbook.com/book/andrew-liu/django-blog/details" target="_blank" rel="noopener">Django搭建简易博客教程</a></li><li><a href="http://djangobook.py3k.cn/2.0/" target="_blank" rel="noopener">The Django Book 中文版</a></li><li><a href="https://github.com/cundi/Django-Design-Patterns-and-Best-Practices" target="_blank" rel="noopener">Django 设计模式与最佳实践</a></li><li><a href="https://github.com/cundi/Web.Development.with.Django.Cookbook" target="_blank" rel="noopener">Django 网站开发 Cookbook</a></li><li><a href="https://www.gitbook.com/book/djangogirlstaipei/django-girls-taipei-tutorial/details" target="_blank" rel="noopener">Django Girls 學習指南</a></li></ul></li><li>Flask<ul><li><a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">Flask 文档中文版</a></li><li><a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="noopener">Jinja2 文档中文版</a></li><li><a href="http://werkzeug-docs-cn.readthedocs.org/zh_CN/latest/" target="_blank" rel="noopener">Werkzeug 文档中文版</a></li><li><a href="http://spacewander.github.io/explore-flask-zh/" target="_blank" rel="noopener">Flask之旅</a></li><li><a href="https://www.gitbook.com/book/wizardforcel/flask-extension-docs/details" target="_blank" rel="noopener">Flask 扩展文档汇总</a></li><li><a href="http://www.pythondoc.com/flask-mega-tutorial/index.html" target="_blank" rel="noopener">Flask 大型教程</a></li><li><a href="https://github.com/sixu05202004/sqlalchemy-docs-cn" target="_blank" rel="noopener">SQLAlchemy 中文文档</a></li></ul></li><li>web.py<ul><li><a href="http://webpy.org/tutorial3.zh-cn" target="_blank" rel="noopener">web.py 0.3 新手指南</a></li><li><a href="http://webpy.org/cookbook/index.zh-cn" target="_blank" rel="noopener">Web.py Cookbook 简体中文版</a></li></ul></li><li>Tornado<ul><li><a href="http://demo.pythoner.com/itt2zh/index.html" target="_blank" rel="noopener">Introduction to Tornado 中文翻译</a></li><li><a href="http://www.nowamagic.net/academy/detail/13321002" target="_blank" rel="noopener">Tornado源码解析</a></li><li><a href="https://tornado-zh.readthedocs.org/zh/latest/" target="_blank" rel="noopener">Tornado 4.3 文档中文版</a><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3></li></ul></li><li><a href="https://github.com/yihui/r-ninja" target="_blank" rel="noopener">R语言忍者秘笈</a><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3></li><li><a href="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md" target="_blank" rel="noopener">Ruby 风格指南</a></li><li><a href="https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md" target="_blank" rel="noopener">Rails 风格指南</a></li><li><a href="http://lrthw.github.io/" target="_blank" rel="noopener">笨方法學 Ruby</a></li><li><a href="http://guides.ruby-china.org/" target="_blank" rel="noopener">Ruby on Rails 指南</a></li><li><a href="https://ihower.tw/rails4/index.html" target="_blank" rel="noopener">Ruby on Rails 實戰聖經</a></li><li><a href="http://railstutorial-china.org/" target="_blank" rel="noopener">Ruby on Rails Tutorial 原书第 3 版</a></li><li><a href="http://rails-practice.com/content/index.html" target="_blank" rel="noopener">Rails 实践</a></li><li><a href="https://www.gitbook.com/book/kelby/rails-beginner-s-guide/details" target="_blank" rel="noopener">Rails 5 开发进阶(Beta)</a></li><li><a href="https://www.gitbook.com/book/rocodev/rails-102/details" target="_blank" rel="noopener">Rails 102</a></li><li><a href="https://wusuopu.gitbooks.io/write-ruby-extension-with-c/content/" target="_blank" rel="noopener">编写Ruby的C拓展</a></li><li><a href="https://ruby-china.org/topics/22386" target="_blank" rel="noopener">Ruby 源码解读</a></li><li><a href="http://deathking.github.io/metaprogramming-in-ruby/" target="_blank" rel="noopener">Ruby中的元编程</a></li><li><a href="http://bbs.konotes.org/workdoc/puppet-27/" target="_blank" rel="noopener">Puppet 2.7 Cookbook 中文版</a><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3></li><li><a href="https://www.gitbook.com/book/kaisery/rust-book-chinese/details" target="_blank" rel="noopener">rust book 中文翻译</a></li><li><a href="https://github.com/rustcc/RustPrimer" target="_blank" rel="noopener">rrust primer</a><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3></li><li><a href="http://twitter.github.io/scala_school/zh_cn/index.html" target="_blank" rel="noopener">Scala课堂 (Twitter的Scala中文教程)</a></li><li><a href="http://twitter.github.io/effectivescala/index-cn.html" target="_blank" rel="noopener">Effective Scala(Twitter的Scala最佳实践的中文翻译)</a></li><li><a href="http://zh.scala-tour.com/" target="_blank" rel="noopener">Scala指南</a><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3></li><li><a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="noopener">Shell脚本编程30分钟入门</a></li><li><a href="http://blog.sae.sina.com.cn/archives/3606" target="_blank" rel="noopener">Bash脚本15分钟进阶教程</a></li><li><a href="https://github.com/me115/linuxtools_rst" target="_blank" rel="noopener">Linux工具快速教程</a></li><li><a href="https://github.com/wzb56/13_questions_of_shell" target="_blank" rel="noopener">shell十三问</a></li><li><a href="https://www.gitbook.com/book/tinylab/shellbook/details" target="_blank" rel="noopener">Shell编程范例</a><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3></li><li><a href="http://numbbbbb.github.io/the-swift-programming-language-in-chinese/" target="_blank" rel="noopener">The Swift Programming Language 中文版</a></li><li><a href="http://dev.swiftguide.cn/" target="_blank" rel="noopener">Swift 语言指南</a></li><li><a href="https://github.com/x140yu/Developing_iOS_8_Apps_With_Swift" target="_blank" rel="noopener">Stanford 公开课，Developing iOS 8 Apps with Swift 字幕翻译文件</a><h2 id="读书笔记及其它"><a href="#读书笔记及其它" class="headerlink" title="读书笔记及其它"></a>读书笔记及其它</h2><h3 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h3></li><li><a href="https://github.com/fool2fish/dragon-book-exercise-answers" target="_blank" rel="noopener">编译原理（紫龙书）中文第2版习题答案</a></li><li><a href="http://www.hawstein.com/posts/make-thiner-programming-pearls.html" target="_blank" rel="noopener">把《编程珠玑》读薄</a></li><li><a href="https://github.com/XiaolongJason/ReadingNote/blob/master/Effective%20C%2B%2B/Effective%20C%2B%2B.md" target="_blank" rel="noopener">Effective C++读书笔记</a></li><li><a href="https://github.com/qyuhen/book" target="_blank" rel="noopener">Golang 学习笔记、Python 学习笔记、C 学习笔记 (PDF)</a></li><li><a href="https://github.com/code4craft/jsoup-learning" target="_blank" rel="noopener">Jsoup 学习笔记</a></li><li><a href="https://github.com/lzjun567/note" target="_blank" rel="noopener">学习笔记: Vim、Python、memcached</a></li><li><a href="http://www.ituring.com.cn/activity/details/2004" target="_blank" rel="noopener">图灵开放书翻译计划–C++、Python、Java等</a></li><li><a href="http://g.yeeyan.org/books/2095" target="_blank" rel="noopener">蒂姆·奥莱利随笔 （由译言网翻译，电子版免费）</a></li><li><a href="http://sicp.readthedocs.org/en/latest/" target="_blank" rel="noopener">SICP 解题集</a></li><li><a href="https://github.com/hacke2/hacke2.github.io/issues/2" target="_blank" rel="noopener">精彩博客集合</a></li><li><a href="http://www.xiaoleilu.com/regex-guide/" target="_blank" rel="noopener">正则表达式简明参考</a></li><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北</a></li><li><a href="http://ganquan.info/standard-c/" target="_blank" rel="noopener">Standard C 语言标准函数库速查 (Cheat Sheet)</a></li><li><a href="http://gh.amio.us/git-cheatsheet-chs/" target="_blank" rel="noopener">Git Cheatsheet Chs</a></li><li><a href="http://www.chengweiyang.cn/gitbook/index.html" target="_blank" rel="noopener">GitBook简明教程</a></li><li><a href="https://github.com/qibaoguang/Study-Step-by-Step/blob/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/javascript_the_good_parts.md" target="_blank" rel="noopener">JavaScript语言精粹</a></li><li><a href="http://producingoss.com/zh/" target="_blank" rel="noopener">制造开源软件</a></li><li><a href="http://www.dianbo.org/9238/stone/tiwendezhihui.htm" target="_blank" rel="noopener">提问的智慧</a></li><li><a href="https://github.com/LearnShare/Learning-Markdown" target="_blank" rel="noopener">Markdown 入门参考</a></li><li><a href="https://github.com/stanzgy/wiki/blob/master/markup/asciidoc-guide.asciidoc" target="_blank" rel="noopener">AsciiDoc简明指南</a></li><li><a href="http://love-oriented.com/pack/" target="_blank" rel="noopener">背包问题九讲</a></li><li><a href="https://github.com/qiwsir/ITArticles" target="_blank" rel="noopener">老齐的技术资料</a></li><li><a href="https://github.com/JacksonTian/fks" target="_blank" rel="noopener">前端技能汇总</a></li><li><a href="https://github.com/zhuangbiaowei/learn-with-open-source" target="_blank" rel="noopener">借助开源项目，学习软件开发</a></li><li><a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Chinese" target="_blank" rel="noopener">前端工作面试问题</a></li><li><a href="https://www.gitbook.com/book/yuanbin/algorithm/details" target="_blank" rel="noopener">leetcode/lintcode题解/算法学习笔记</a></li><li><a href="https://github.com/li-xinyang/FEND_Note" target="_blank" rel="noopener">前端开发笔记本</a><h3 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h3></li><li><a href="http://appium.io/slate/cn/v1.2.0/" target="_blank" rel="noopener">移动APP自动化测试优秀框架Appium API Reference V1.2.0 CN</a></li></ul><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="http://siberiawolf.com/free_programming/index.html?utm_source=androiddevtools&amp;utm_medium=website#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">链接1</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语言无关类&quot;&gt;&lt;a href=&quot;#语言无关类&quot; class=&quot;headerlink&quot; title=&quot;语言无关类&quot;&gt;&lt;/a&gt;语言无关类&lt;/h2&gt;&lt;h3 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;
      
    
    </summary>
    
      <category term="资源" scheme="http://blog.inbelieve.top/categories/resource/"/>
    
    
      <category term="存档" scheme="http://blog.inbelieve.top/tags/file/"/>
    
  </entry>
  
</feed>
