[{"title":"浏览器User-Agent总结","date":"2018-06-17T13:07:04.000Z","path":"server/20180617-23.html","text":"UserAgent中文名为用户代理，是Http协议中header头的组成部分，UserAgent也简称UA。它是一个特殊字符串头，是一种向访问网站提供你所使用的浏览器类型及版本、操作系统及版本、浏览器内核、等信息的标识。通过这个标识，用户所访问的网站可以显示不同的排版从而为用户提供更好的体验或者进行信息统计；例如用手机访问谷歌和电脑访问是不一样的，这些是谷歌根据访问者的UA来判断的。UA可以进行伪装。 浏览器的UA字串的标准格式：浏览器标识 (操作系统标识 加密等级标识 浏览器语言) 渲染引擎标识版本信息。 字串说明：1、浏览器标识出于兼容及推广等目的，很多浏览器的标识相同（如Mozilla/5.0），因此浏览器标识并不能说明浏览器的真实版本，真实版本信息在UA字串尾部可以找到。 2、操作系统标识 平台 标识 备注 FreeBSD X11 FreeBSD(version no.)i386 FreeBSD X11 FreeBSD(version no.)AMD64 Linux X11 Linux ppc Linux X11 Linux ppc64 Linux X11 Linux i686 Linux X11 Linux x86_64 Mac Macintosh PPC Mac OS X Mac Macintosh Intel Mac OS X Solaris X11 SunOS i86pc Solaris X11 SunOS sun4u Windows Windows NT 10.0 windows 10 Windows Windows NT 6.1 windows 7 Windows Windows NT 6.0 windows Vista Windows Windows NT 5.2 windows 2003 Windows Windows NT 5.1 windows xp Windows Windows NT 5.0 windows 2000 3、加密等级标识 N:表示无安全加密 I:表示弱安全加密 U:表示强安全加密 4、浏览器语言在首选项&gt;常规&gt;语言中指定的语言 5、渲染引擎显示浏览器使用的主流渲染引擎有：Gecko、WebKit、KHTML、Presto、Trident、Tasman等，格式为：渲染引擎/版本信息 6、版本信息显示浏览器的真实版本信息，格式为：浏览器/版本信息 浏览器User-Agent的详细信息PC端： safari5.1–MACUser-Agent:Mozilla/5.0(Macintosh;U;IntelMacOSX10_6_8;en-us)AppleWebKit/534.50(KHTML,likeGecko)Version/5.1Safari/534.50 safari5.1–WindowsUser-Agent:Mozilla/5.0(Windows;U;WindowsNT6.1;en-us)AppleWebKit/534.50(KHTML,likeGecko)Version/5.1Safari/534.50 IE9.0User-Agent:Mozilla/5.0(compatible;MSIE9.0;WindowsNT6.1;Trident/5.0; IE8.0User-Agent:Mozilla/4.0(compatible;MSIE8.0;WindowsNT6.0;Trident/4.0) IE7.0User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT6.0) IE6.0User-Agent:Mozilla/4.0(compatible;MSIE6.0;WindowsNT5.1) Firefox4.0.1–MACUser-Agent:Mozilla/5.0(Macintosh;IntelMacOSX10.6;rv:2.0.1)Gecko/20100101Firefox/4.0.1 Firefox4.0.1–WindowsUser-Agent:Mozilla/5.0(WindowsNT6.1;rv:2.0.1)Gecko/20100101Firefox/4.0.1 Opera11.11–MACUser-Agent:Opera/9.80(Macintosh;IntelMacOSX10.6.8;U;en)Presto/2.8.131Version/11.11 Opera11.11–WindowsUser-Agent:Opera/9.80(WindowsNT6.1;U;en)Presto/2.8.131Version/11.11 Chrome17.0–MACUser-Agent:Mozilla/5.0(Macintosh;IntelMacOSX10_7_0)AppleWebKit/535.11(KHTML,likeGecko)Chrome/17.0.963.56Safari/535.11 傲游（Maxthon）User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;Maxthon2.0) 腾讯TTUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;TencentTraveler4.0) 世界之窗（TheWorld）2.xUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1) 世界之窗（TheWorld）3.xUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;TheWorld) 搜狗浏览器1.xUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;Trident/4.0;SE2.XMetaSr1.0;SE2.XMetaSr1.0;.NETCLR2.0.50727;SE2.XMetaSr1.0) 360浏览器User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;360SE) AvantUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;AvantBrowser) GreenBrowserUser-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1) 移动设备端： safariiOS4.33–iPhoneUser-Agent:Mozilla/5.0(iPhone;U;CPUiPhoneOS4_3_3likeMacOSX;en-us)AppleWebKit/533.17.9(KHTML,likeGecko)Version/5.0.2Mobile/8J2Safari/6533.18.5 safariiOS4.33–iPodTouchUser-Agent:Mozilla/5.0(iPod;U;CPUiPhoneOS4_3_3likeMacOSX;en-us)AppleWebKit/533.17.9(KHTML,likeGecko)Version/5.0.2Mobile/8J2Safari/6533.18.5 safariiOS4.33–iPadUser-Agent:Mozilla/5.0(iPad;U;CPUOS4_3_3likeMacOSX;en-us)AppleWebKit/533.17.9(KHTML,likeGecko)Version/5.0.2Mobile/8J2Safari/6533.18.5 AndroidN1User-Agent:Mozilla/5.0(Linux;U;Android2.3.7;en-us;NexusOneBuild/FRF91)AppleWebKit/533.1(KHTML,likeGecko)Version/4.0MobileSafari/533.1 AndroidQQ浏览器ForandroidUser-Agent:MQQBrowser/26Mozilla/5.0(Linux;U;Android2.3.7;zh-cn;MB200Build/GRJ22;CyanogenMod-7)AppleWebKit/533.1(KHTML,likeGecko)Version/4.0MobileSafari/533.1 AndroidOperaMobileUser-Agent:Opera/9.80(Android2.3.4;Linux;OperaMobi/build-1107180945;U;en-GB)Presto/2.8.149Version/11.10 AndroidPadMotoXoomUser-Agent:Mozilla/5.0(Linux;U;Android3.0;en-us;XoomBuild/HRI39)AppleWebKit/534.13(KHTML,likeGecko)Version/4.0Safari/534.13 BlackBerryUser-Agent:Mozilla/5.0(BlackBerry;U;BlackBerry9800;en)AppleWebKit/534.1+(KHTML,likeGecko)Version/6.0.0.337MobileSafari/534.1+ WebOSHPTouchpadUser-Agent:Mozilla/5.0(hp-tablet;Linux;hpwOS/3.0.0;U;en-US)AppleWebKit/534.6(KHTML,likeGecko)wOSBrowser/233.70Safari/534.6TouchPad/1.0 NokiaN97User-Agent:Mozilla/5.0(SymbianOS/9.4;Series60/5.0NokiaN97-1/20.0.019;Profile/MIDP-2.1Configuration/CLDC-1.1)AppleWebKit/525(KHTML,likeGecko)BrowserNG/7.1.18124 WindowsPhoneMangoUser-Agent:Mozilla/5.0(compatible;MSIE9.0;WindowsPhoneOS7.5;Trident/5.0;IEMobile/9.0;HTC;Titan) UC无User-Agent:UCWEB7.0.2.37/28/999 UC标准User-Agent:NOKIA5700/UCWEB7.0.2.37/28/999 UCOpenwaveUser-Agent:Openwave/UCWEB7.0.2.37/28/999 UCOperaUser-Agent:Mozilla/4.0(compatible;MSIE6.0;)Opera/UCWEB7.0.2.37/28/999","tags":[{"name":"HTTP","slug":"http","permalink":"http://blog.inbelieve.top/tags/http/"},{"name":"HTML5","slug":"html5","permalink":"http://blog.inbelieve.top/tags/html5/"}]},{"title":"HTTP状态码","date":"2018-06-17T13:06:49.000Z","path":"server/20180617-22.html","text":"状态码 含义 100 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 102 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 200 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。 202 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 203 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。 207 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 300 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 302 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 305 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306 在最新版的规范中，306状态码已经不再被使用。 307 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 400 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。 401 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 402 该状态码是为了将来可能的需求而预留的。 403 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。 408 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 415 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 417 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 421 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV） 424 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） 425 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426 客户端应当切换到TLS/1.0。（RFC 2817） 449 由微软扩展，代表请求应当在执行完适当的操作后进行重试。 500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 504 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误 505 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) 509 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510 获取资源所需要的策略并没有没满足。（RFC 2774）","tags":[{"name":"HTTP","slug":"http","permalink":"http://blog.inbelieve.top/tags/http/"}]},{"title":"linux上安装SS","date":"2018-06-17T13:06:13.000Z","path":"server/20180617-21.html","text":"1. 安装 centos(如果python版本过低，请升级到2.7) sudo yum updatesudo yum install python-setuptools &amp;&amp; easy_install pipsudo pip install shadowsocks debian/ubantu sudo apt update sudo apt install python-gevent python-pippip install shadowsocks 2. 配置touch /etc/shadowsocks.jsonvim /etc/shadowsocks.json&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;port_password&quot;:&#123; &quot;9001&quot;:&quot;abcdef&quot;, &quot;9001&quot;:&quot;abcdef&quot;, &quot;9002&quot;:&quot;abcdef&quot;, &quot;9003&quot;:&quot;abcdef&quot; &#125;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;rc4-md5&quot; &#125; 3. 启动ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop 4. 设置开机启动，再 /etc/rc.local中添加启动命令sudo vim /etc/rc.localsudo /usr/local/bin/ssserver -c /etc/shadowsocks.json -d start","tags":[{"name":"Linux","slug":"linux","permalink":"http://blog.inbelieve.top/tags/linux/"},{"name":"Centos","slug":"centos","permalink":"http://blog.inbelieve.top/tags/centos/"}]},{"title":"浅谈javascript中的订阅发布模式","date":"2018-06-17T13:05:53.000Z","path":"server/20180617-20.html","text":"事件驱动作为javascript的一个重大特性，而事件驱动的实现原理正是订阅发布模式，本文为大家奉献简单的订阅发布模式。var PubSub = &#123; handlers: &#123;&#125;&#125;PubSub.on = function(eventType, handler) &#123; if(!(eventType in this.handlers)) &#123; this.handlers[eventType] = [] &#125; this.handlers[eventType].push(handler) return this &#125;PubSub.emit = function(eventType) &#123; var handlerArgs = [].protoType.slice.call(arguments, 1) for(var i = 0; i &lt; this.handlers[eventType].length; i++) &#123; this.handlers[eventType][i].apply(this, handlerArgs); &#125; return this;&#125;PubSub.off = function(eventType, handler) &#123; if(!(eventType in this.handlers)) &#123; return &#125; if(handler == undefined) &#123; delete this.handlers[eventType] &#125; var index = this.handlers[eventType].indexOf(handler) if(index !== -1) &#123; this.handlers[eventType].splice(index, 1) &#125; return this&#125; Pubsub对象实现事件的绑定，解绑，触发等","tags":[{"name":"JavaScript","slug":"javascript","permalink":"http://blog.inbelieve.top/tags/javascript/"},{"name":"设计模式","slug":"mode","permalink":"http://blog.inbelieve.top/tags/mode/"}]},{"title":"ip地址类别和私有网段","date":"2018-06-17T11:09:48.000Z","path":"server/20180617-19.html","text":"我们常用路由器或者虚拟机，发现基本我们的内网都是192.168.x.x或者是10.104.x.x的网关，为什么我们的路由器长设置成这个网关的呢，这就跟计算机网络的私有网段有关系 互联网上的IP地址统一由一个叫IANA(Internet Assigned Numbers Authority，互联网网络号分配机构)的组织来管理。根据用途和安全性级别的不同，IP地址还可以大致分为两类：公共地址（public IP address）和私有地址（private IP address，也译作保留地址）。公用地址在Internet中使用，可以在Internet中随意访问。私有地址只能在内部网络中使用，只有通过代理服务器才能与Internet通信。 下面是各类网段ip范围 （“[”表示包含，“）”不包含）： 类别 IP前4位/x 十进制范围 A (0000, 1000)/8 [1, 128) B [1000, 1100)/16 [128, 192) C [1100, 1110)/24 [192, 224) D(多播) [1110, 1111) [224, 240) E(保留) [1111, 1111] [240, 255) 私有网络ip范围： 类别 IP范围 网络数量 A 10.0.0.0 ~ 10.255.255.255 (10/8 prefix) 1 B 17.16.0.0 ~ 17.32.255.255 (17.16/16 prefix) 16 C 192.168.0.0 ~ 1192.168.255.255 (192.168/24 prefix) 255 此外，比较特殊的ip地址有下面几个 0.0.0.0 次地址一般用于路由器的默认转发项； 255.255.255.255 一般用作同一局域网下 的广播地址； 127.0.0.1 用于回环测试的地址","tags":[{"name":"HTTP","slug":"http","permalink":"http://blog.inbelieve.top/tags/http/"},{"name":"Web服务器","slug":"webserver","permalink":"http://blog.inbelieve.top/tags/webserver/"}]},{"title":"composer设置国内镜像","date":"2018-06-17T11:06:04.000Z","path":"server/20180617-18.html","text":"最近因为使用composer安装依赖，发现比较慢(因为墙的原因)，所以找了一下国内镜像地址配置下，这样可以加快下载速度，方法如下： 在linux或window的命令行，输入下面命令composer config -g repo.packagist composer https://packagist.phpcomposer.com","tags":[{"name":"PHP","slug":"php","permalink":"http://blog.inbelieve.top/tags/php/"}]},{"title":"Composer设置忽略版本匹配","date":"2018-06-17T11:03:07.000Z","path":"server/20180617-17.html","text":"最近使用composer安装时发现提示php的版本不匹配。执行composer install遇到错误：Your requirements could not be resolved to an installable set of packages. 这是因为不匹配composer.json要求的版本。 完整错误如下： [PHP]vagrant@homestead:/usr/share/nginx/html/laravel-1$ sudo composer installLoading composer repositories with package informationInstalling dependencies (including require-dev) from lock fileYour requirements could not be resolved to an installable set of packages. Problem 1 - Installation request for doctrine/instantiator 1.0.3 -&gt; satisfiable by doctrine/instantiator[1.0.3]. - doctrine/instantiator 1.0.3 requires php ~5.3 -&gt; your PHP version (7.0.3) does not satisfy that requirement. Problem 2 - doctrine/instantiator 1.0.3 requires php ~5.3 -&gt; your PHP version (7.0.3) does not satisfy that requirement. - phpunit/phpunit-mock-objects 2.3.0 requires doctrine/instantiator ~1.0,&gt;=1.0.1 -&gt; satisfiable by doctrine/instantiator[1.0.3]. - Installation request for phpunit/phpunit-mock-objects 2.3.0 -&gt; satisfiable by phpunit/phpunit-mock-objects[2.3.0]. 提示我的PHP 7版本太高，不符合composer.json需要的版本，但是在PHP 7下应该也是可以运行的，composer可以设置忽略版本匹配，命令是：composer install --ignore-platform-reqs orcomposer update --ignore-platform-reqs 再次执行composer命令可以正常安装包了。","tags":[{"name":"PHP","slug":"php","permalink":"http://blog.inbelieve.top/tags/php/"}]},{"title":"php获取客户端IP","date":"2018-06-17T11:02:52.000Z","path":"server/20180617-16.html","text":"比较 HTTP_CLIENT_IP HTTP_X_FORWARDED_FOR REMOTE_ADDR最近做项目的时候，遇到一个需要记录客户端ip的，后台语言是php,我想了一下，用REMOTE_ADDR吧。可是呢，后来发现其实这个还有很多其他的获取方式，HTTP_CLIENT_IP, HTTP_X_FORWARDED_FOR都可以获取，我仔细查了一下资料，总结一下这三者的区别，另附完整解决方法： HTTP_CLIENT_IP头是有的，只是未成标准，不一定服务器都实现了。 HTTP_X_FORWARDED_FOR 是有标准定义，用来识别经过HTTP代理后的客户端IP地址，格式：clientip,proxy1,proxy2。详细解释见 http://zh.wikipedia.org/wiki/X-Forwarded-For REMOTE_ADDR 是可靠的， 它是最后一个跟你的服务器握手的IP，可能是用户的代理服务器，也可能是自己的反向代理。 顺便说下$_SERVER和getenv的区别，getenv不支持IIS的isapi方式运行的phpfunction getIp() &#123; if (getenv ( &quot;HTTP_CLIENT_IP&quot; ) &amp;&amp; strcasecmp ( getenv ( &quot;HTTP_CLIENT_IP&quot; ), &quot;unknown&quot; )) &#123; $ip = getenv ( &quot;HTTP_CLIENT_IP&quot; ); &#125; elseif (getenv ( &quot;HTTP_X_FORWARDED_FOR&quot; ) &amp;&amp; strcasecmp ( getenv ( &quot;HTTP_X_FORWARDED_FOR&quot; ), &quot;unknown&quot; )) &#123; $ip = getenv ( &quot;HTTP_X_FORWARDED_FOR&quot; ); &#125; elseif (getenv ( &quot;REMOTE_ADDR&quot; ) &amp;&amp; strcasecmp ( getenv ( &quot;REMOTE_ADDR&quot; ), &quot;unknown&quot; )) &#123; $ip = getenv ( &quot;REMOTE_ADDR&quot; ); &#125; elseif (isset ( $_SERVER [&apos;REMOTE_ADDR&apos;] ) &amp;&amp; $_SERVER [&apos;REMOTE_ADDR&apos;] &amp;&amp; strcasecmp ( $_SERVER [&apos;REMOTE_ADDR&apos;], &quot;unknown&quot; )) &#123; $ip = $_SERVER [&apos;REMOTE_ADDR&apos;]; &#125; else &#123; $ip = &quot;unknown&quot;; &#125; return ($ip);&#125; REMOTE_ADDR不可以显式的伪造，虽然可以通过代理将ip地址隐藏，但是这个地址仍然具有参考价值，因为它就是与你的服务器实际连接的ip地址。 相比之下，前两种ip地址都可以通过http header来伪造，但并不意味着它们一无是处。生产环境中很多服务器隐藏在负载均衡节点后面，你通过REMOTE_ADDR只能获取到负载均衡节点的ip地址，一般的负载均衡节点会把前端实际的ip地址通过HTTP_CLIENT_IP或者HTTP_X_FORWARDED_FOR这两种http头传递过来","tags":[{"name":"PHP","slug":"php","permalink":"http://blog.inbelieve.top/tags/php/"}]},{"title":"js数组之forEach,every,some,filter,map的区别","date":"2018-06-17T09:27:45.000Z","path":"frontend/20180617-15.html","text":"js数组有很多操作方法，其中forEach,every,some,filter,map是常容易混淆用法的，下面我来解释其中的区别var list = [&#123; &quot;id&quot;: 1, &quot;age&quot;: 19&#125;,&#123; &quot;id&quot;: 2, &quot;age&quot;: 18&#125;]var result = list.forEach((val,index) =&gt; &#123; val.id = val.id + 1 //return &#125;)console.error(result, list)var boolData = list.every(val =&gt; &#123; return val.age &gt; 18&#125;)console.error(boolData, list);var boolData2 = list.some(val =&gt; &#123; return val.age &gt; 18&#125;)console.error(boolData2, list);var data = list.filter(val =&gt; &#123; return val.age &gt; 18&#125;)console.error(data, list);var mapData = list.map(val =&gt; &#123; return (val.id) * 2&#125;)console.error(mapData, list); 输出结果如下：undefined, [ &#123; id: 2, age: 19 &#125;, &#123; id: 3, age: 18 &#125; ] #forEachfalse, [ &#123; id: 2, age: 19 &#125;, &#123; id: 3, age: 18 &#125; ] #everytrue, [ &#123; id: 2, age: 19 &#125;, &#123; id: 3, age: 18 &#125; ] #some[ &#123; id: 2, age: 19 &#125; ], [ &#123; id: 2, age: 19 &#125;, &#123; id: 3, age: 18 &#125; ] #filter[ 4, 6 ], [ &#123; id: 2, age: 19 &#125;, &#123; id: 3, age: 18 &#125; ] #map 可以看出： forEach 是没有返回值的，你可以直接修改回调的val值来改变原数组，也可以利用val来生成新数组 （没有返回值） every 是用来做判断，判断数组中的所有元素是否都符合某一个条件吗，符合则返回值是true,具体条件是有回调里面的return的值来决定（返回布尔值） some 是用来做判断，判断数组中的是否存在某一个元素符合某一个条件吗，符合则返回值是true,具体条件是有回调里面的return的值来决定（返回布尔值） filter 是用来过滤，可以过滤出来数组中的某些符合条件的元素集合，具体条件是有回调里面的return的值来决定 （返回新数组） map 是用来根据原数组生成新数组的，元素是回调里面返回的值 （返回新数组）","tags":[{"name":"JavaScript","slug":"javascript","permalink":"http://blog.inbelieve.top/tags/javascript/"}]},{"title":"js正则表达式之爬虫","date":"2018-06-17T09:27:27.000Z","path":"frontend/20180617-14.html","text":"前言通过爬虫爬去网页的dom之后就需要用正则来获取相关的信息，下面来说下正则表达式在爬虫中的应用 匹配 对于Html来说，一般需要匹配的就是相应DOM结构，比如标签属性，内容和数目之类的。 拿一个简单的标签来说比如&lt;span&gt;username&lt;/span&gt;，我们想要拿到username这个内容来用正则实现。这里要先补充一些需要使用的或者比较关键的正则关键词： 自定义匹配多种字符 - [ ] 使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。 用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。 虽然可以匹配其中任意一个，但是只能是一个，不是多个。 修饰匹配次数 - {}，?，+，* {n} - 表达式重复n次，比如：”/w{2}” 相当于 “/w/w”；”a{5}” 相当于 “aaaaa” {m,n} - 表达式至少重复m次，最多重复n次，比如：”ba{1,3}”可以匹配 “ba”或”baa”或”baaa” {m,} - 表达式至少重复m次，比如：”/w/d{2,}”可以匹配 “a12”,”_456”,”M12344”… ? - 匹配表达式0次或者1次，相当于 {0,1}，比如：”a[cd]?”可以匹配 “a”,”ac”,”ad” + - 表达式至少出现1次，相当于 {1,}，比如：”a+b”可以匹配 “ab”,”aab”,”aaab”… * - 表达式不出现或出现任意次，相当于 {0,}，比如：”/^*b”可以匹配 “b”,”^^^b”… 用于group的字符 - () 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到 用于扩展表达式含义 g：代表可以进行全局匹配 i：代表不区分大小写匹配 m：代表可以进行多行匹配 上面几个概念就是我们所需要的所有东西了。 接下里开始匹配span标签并且取出里面的内容&lt;span&gt;username&lt;/span&gt; 使用下面的正则即可，其中非贪婪模式很简单的避免了多个相同标签时匹配不正确的问题/&lt;span&gt;(.*?)&lt;\\/span&gt;/ 如果要取出某些属性的标签比如&lt;span id=&quot;user&quot;&gt;username&lt;/span&gt; 则可以使用如下正则/&lt;span id=&quot;(.*?)&quot;&gt;(.*?)&lt;\\/span&gt;/ 这样就能够简单快速解决html里面各种标签的数据获取问题 筛选对于匹配出来的数据，如果我们需要全局匹配，可以使用String.match(RegExp)方法。不过该方法只能获取一次的匹配结果，如果需要匹配大段文本中多次的结果就需要使用RegExp.exec(string)方法进行匹配。var html = &apos;&lt;span id=&quot;sp_1&quot;&gt;a&lt;/span&gt;&lt;span id=&quot;sp_2&quot;&gt;b&lt;/span&gt;&lt;span id=&quot;sp_3&quot;&gt;c&lt;/span&gt;&apos;;var reg = /&lt;span id=&quot;(.*?)&quot;&gt;(.*?)&lt;\\/span&gt;/g;var result;while ((result = reg.exec(html)) != null) &#123; console.log(result[1],result[2])&#125;//sp_1 a//sp_2 b//sp_3 c 这样，对于绝大部分网页内容分析筛选的工作都可以使用简单的正则快速的完成了。","tags":[{"name":"JavaScript","slug":"javascript","permalink":"http://blog.inbelieve.top/tags/javascript/"}]},{"title":"nodejs之pm2","date":"2018-06-17T09:27:14.000Z","path":"frontend/20180617-13.html","text":"简介pm2 是一个带有负载均衡功能的Node应用的进程管理器.当你要把你的独立代码利用全部的服务器上的所有CPU,并保证进程永远都活着,0秒的重载, PM2可以作为完美的守护进程。 安装npm install -g pm2 pm2常用命令$ pm2 start app.js # 启动app.js应用程序$ pm2 start app.js -i 4 # cluster mode 模式启动4个app.js的应用实例 # 4个应用程序会自动进行负载均衡$ pm2 start app.js --name=&quot;api&quot; # 启动应用程序并命名为 &quot;api&quot;$ pm2 start app.js --watch # 当文件变化时自动重启应用$ pm2 start script.sh # 启动 bash 脚本$ pm2 list # 列表 PM2 启动的所有的应用程序$ pm2 monit # 显示每个应用程序的CPU和内存占用情况$ pm2 show [app-name] # 显示应用程序的所有信息$ pm2 logs # 显示所有应用程序的日志$ pm2 logs [app-name] # 显示指定应用程序的日志$ pm2 flush$ pm2 stop all # 停止所有的应用程序$ pm2 stop 0 # 停止 id为 0的指定应用程序$ pm2 restart all # 重启所有应用$ pm2 reload all # 重启 cluster mode下的所有应用$ pm2 gracefulReload all # Graceful reload all apps in cluster mode$ pm2 delete all # 关闭并删除所有应用$ pm2 delete 0 # 删除指定应用 id 0$ pm2 scale api 10 # 把名字叫api的应用扩展到10个实例$ pm2 reset [app-name] # 重置重启数量$ pm2 startup # 创建开机自启动命令$ pm2 save # 保存当前应用列表$ pm2 resurrect # 重新加载保存的应用列表$ pm2 update # Save processes, kill PM2 and restore processes$ pm2 generate # Generate a sample json configuration file$ pm2 deploy app.json prod setup # Setup &quot;prod&quot; remote server$ pm2 deploy app.json prod # Update &quot;prod&quot; remote server$ pm2 deploy app.json prod revert 2 # Revert &quot;prod&quot; remote server by 2$ pm2 module:generate [name] # Generate sample module with name [name]$ pm2 install pm2-logrotate # Install module (here a log rotation system)$ pm2 uninstall pm2-logrotate # Uninstall module$ pm2 publish # Increment version, git push and npm publish","tags":[{"name":"JavaScript","slug":"javascript","permalink":"http://blog.inbelieve.top/tags/javascript/"},{"name":"NodeJs","slug":"nodejs","permalink":"http://blog.inbelieve.top/tags/nodejs/"}]},{"title":"nodejs之追加内容到文件","date":"2018-06-17T09:27:01.000Z","path":"frontend/20180617-12.html","text":"最近用node跑一个简单服务，需要不停地将请求的内容写日志，所以使用appendFile方法追加内容到文件里面var fs = require(&apos;fs&apos;); var data = &apos;hello world&apos;; fs.appendFile(&apos;./log.txt&apos;,data,&apos;utf8&apos;,function(err)&#123; if(err) &#123; console.log(err); &#125; &#125;);","tags":[{"name":"JavaScript","slug":"javascript","permalink":"http://blog.inbelieve.top/tags/javascript/"},{"name":"NodeJs","slug":"nodejs","permalink":"http://blog.inbelieve.top/tags/nodejs/"}]},{"title":"JavaScript中typeof的原理","date":"2018-06-17T09:26:46.000Z","path":"frontend/20180617-11.html","text":"今天遇到别人提的一个问题，js中typeof的原理是什么，我只知道typeof null == &#39;object&#39;，但是对于具体原理还真的不清楚，后来找了一下资料，发现如此。 原理是这样的， 不同的对象在底层都表示为二进制， 在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回object。 其实这个是一个历史遗留的bug，在 javascript 的最初版本中，使用的 32 位系统，为了性能考虑使用低位存储了变量的类型信息： 000：对象 1：整数 010：浮点数 100：字符串 110：布尔 有 2 个值比较特殊： undefined：用 - （−2^30）表示。 null：对应机器码的 NULL 指针，一般是全零。 所以当你使用typeof null时返回就是object了","tags":[{"name":"JavaScript","slug":"javascript","permalink":"http://blog.inbelieve.top/tags/javascript/"}]},{"title":"javascript中检查对象是否存在环","date":"2018-06-17T09:26:30.000Z","path":"frontend/20180617-10.html","text":"JavaScript中，为了保证代码健壮性，我们需要确认对象中不存在环，现在有2种方法检测js对象是否有环 方法一 function cycleDetector (obj) &#123; console.log(arguments) // 请添加代码 let result = false; try &#123; JSON.stringify(obj); &#125; catch (e) &#123; result = true; &#125; finally &#123; return result; &#125;&#125; 方法二 function cycleDetector2(obj) &#123; let hasCircle = false, cache = []; (function(obj) &#123; Object.keys(obj).forEach(key =&gt; &#123; const value = obj[key] if (typeof value == &apos;object&apos; &amp;&amp; value !== null) &#123; const index = cache.indexOf(value) if (index !== -1) &#123; hasCircle = true return &#125; else &#123; cache.push(value) arguments.callee(value) // (注:箭头函数没有arguments对象，此时的arguments指向该匿名函数的参数) &#125; &#125; &#125;) &#125;)(obj) return hasCircle&#125; 运行代码const obj = &#123; foo: &#123; name: &apos;foo&apos;, bar: &#123; name: &apos;bar&apos;, baz: &#123; name: &apos;baz&apos;, aChild: null //待会让它指向obj.foo &#125; &#125; &#125;&#125;obj.foo.bar.baz.aChild = obj.foovar currentTime = new Date().getTime()var flag = cycleDetector(obj)var endTime = new Date().getTime()var time = endTime - currentTimeconsole.error(flag, time)var currentTime2 = new Date().getTime()var flag2 = cycleDetector2(obj)var endTime2 = new Date().getTime()var time2 = endTime2 - currentTime2console.error(flag2, time2) 返回结果&#123; &apos;0&apos;: &#123; foo: &#123; name: &apos;foo&apos;, bar: [Object] &#125; &#125; &#125;true 5true 0 第一种才用try catch的捕获异常的方法来判断，需要的时间更长，代码更简洁。第二种方法时间更快,但是它执行递归，逻辑较第一种更复杂，空间也需要更大。","tags":[{"name":"JavaScript","slug":"javascript","permalink":"http://blog.inbelieve.top/tags/javascript/"}]},{"title":"nginx配置允许跨域","date":"2018-06-17T09:23:06.000Z","path":"server/20180617-9.html","text":"nginx设置允许跨域add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;; #设置允许跨域add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; #设置跨域是否需要认证(此处可不需要)add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; #设置允许通过跨域方法add_header &apos;Access-Control-Allow-Headers&apos; &apos;X-Requested-With&apos;; #设置允许跨域的header 这一段可以放在http、server、location里面分别代表不同程度的跨域，其中Access-Control-Allow-Headers，Access-Control-Allow-Credentials可以不设置","tags":[{"name":"Web服务器","slug":"webserver","permalink":"http://blog.inbelieve.top/tags/webserver/"},{"name":"Nginx","slug":"nginx","permalink":"http://blog.inbelieve.top/tags/nginx/"}]},{"title":"Nginx之upstream负载均衡","date":"2018-06-17T09:22:50.000Z","path":"server/20180617-8.html","text":"1. 准备三台机器192.168.2.151 web服务器192.168.2.152 web服务器192.168.2.150 负载均衡服务器 2. 三台机器都配置,其中151,152作为web服务器，150作为负载均衡 ubuntu/debiansudo apt update -ysudo apt install nginx centossudo yum install nginx -y 安装成功后启动nginx 3 配置负载均衡服务器：vim /etc/nginx/nginx.conf 内容如下：user www-data; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events &#123; worker_connections 1024; &#125; http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; upstream your.website.name &#123; server 192.168.2.151:80; server 192.168.2.152:80; &#125; server &#123; listen 80; server_name your.website.name; charset utf-8; location / &#123; proxy_pass http://your.website.name; proxy_set_header X-Real-IP $remote_addr; client_max_body_size 100m; &#125; location ~ ^/(WEB-INF)/ &#123; deny all; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /var/www/html/; &#125; &#125; &#125; 浏览器打开192.168.2.150，如果151、152交替显示则表明试验成功。 4. 其他的功能扩展(1)、轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。upstream your.website.name &#123; server 192.168.2.151:80; server 192.168.2.152:80; &#125; (2)、weight指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。例如：upstream your.website.name &#123; server 192.168.2.151 weight=5 max_fails=3 fail_timeout=20s;; server 192.168.2.152 weight=10 max_fails=3 fail_timeout=20s;;&#125; (3)、ip_hash每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。例如：upstream your.website.name &#123; ip_hash; server 192.168.2.151:80; server 192.168.2.152:80;&#125; (4)、fair（需要安装第三方库upstream-fair支持）按后端服务器的响应时间来分配请求，响应时间短的优先分配。upstream your.website.name &#123; server 192.168.2.151:80; server 192.168.2.152:80; fair;&#125; (5)、url_hash（需要安装第三方库Nginx_upstream_hash支持） 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法upstream your.website.name &#123; server 192.168.2.151:80; server 192.168.2.152:80; hash $request_uri; hash_method crc32;&#125; (6)、建议upstream your.website.name&#123; #定义负载均衡设备的Ip及设备状态 ip_hash; server 127.0.0.1:8000 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6801; server 127.0.0.1:6802 backup;&#125; 解释：1.down 表示单前的server暂时不参与负载2.weight 默认为1.weight越大，负载的权重就越大。3.max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误4.fail_timeout:max_fails次失败后，暂停的时间。5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 5.总结实际上，我们可以部署时，设置服务器作为backup备份，设置服务器暂时不开启(down),必要活动时在开启，跟进服务器的不同配置设置不同的比重(weight),还可以设置默认同一个ip自动进同一个服务器，这样保证session的一致性。","tags":[{"name":"Web服务器","slug":"webserver","permalink":"http://blog.inbelieve.top/tags/webserver/"},{"name":"Nginx","slug":"nginx","permalink":"http://blog.inbelieve.top/tags/nginx/"}]},{"title":"Nginx之alias与root","date":"2018-06-17T09:22:34.000Z","path":"server/20180617-7.html","text":"Nginx的location块中的root用法，大家应该都知道，就是用来映射路径用的，而alias也是用来映射路径用的，n那么这2者有什么区别呢？ 先看root的用法location /request_path/image/ &#123; root /local_path/image/;&#125; 当客户端请求 /request_path/image/123.jpg的时候，实际上是映射的/local_path/image/request_path/image/123.jpg; alias的用法location /request_path/image/ &#123; alias /local_path/image/;&#125; 当客户端请求 /request_path/image/123.png 的时候，Nginx把请求映射为/local_path/image/123.png 总结，root和alias都可以用来映射路径，root后面跟的时候之后的真实路径，alias则可以用来显示真实路径，也可以用来重写路径，一般我们在location / 里面使用root,而在location /other/ 里面使用alias。 大家可以去配置试一下，有什么不对的，请指正。","tags":[{"name":"Web服务器","slug":"webserver","permalink":"http://blog.inbelieve.top/tags/webserver/"},{"name":"Nginx","slug":"nginx","permalink":"http://blog.inbelieve.top/tags/nginx/"}]},{"title":"服务器之负载均衡","date":"2018-06-17T09:22:07.000Z","path":"server/20180617-6.html","text":"负载均衡所谓负载均衡，就是将任务分摊到多个操作单元上进行执行，因为多台服务器的承载能力各不相同，这可能体现在硬件配置、网络带宽的差异，也可能因为某台服务器身兼多职，我们所说的“均衡”，也就是希望所有服务器都不要过载，并且能够最大程度地发挥作用。下面谈谈目前流行的几种web负载均衡的策略。 一、HTTP重定向当用户发来请求的时候，Web服务器通过修改HTTP响应头中的Location标记来返回一个新的url，然后浏览器再继续请求这个新url，实际上就是页面重定向。通过重定向，来达到“负载均衡”的目标。例如，我们在下载PHP源码包的时候，点击下载链接时，为了解决不同国家和地域下载速度的问题，它会返回一个离我们近的下载地址。重定向的HTTP返回码是302。重定向非常容易实现，并且可以自定义各种策略。但是，它在大规模访问量下，性能不佳。而且，给用户的体验也不好，实际请求发生重定向，增加了网络延时。 性能缺陷： 吞吐率限制主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs/s，那么主服务器的吞吐率要达到3000reqs/s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs/s，那么平均分配到子服务器的吞吐率为2000reqs/s，而现子服务器的最大吞吐率为1000reqs/s，因此就得增加子服务器的数量，增加到6个才能满足。 重定向访问深度不同有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。 我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。 二、反向代理负载均衡反向代理服务的核心工作主要是转发HTTP请求，扮演了浏览器端和后台Web服务器中转的角色。因为它工作在HTTP层（应用层），也就是网络七层结构中的第七层，因此也被称为“七层负载均衡”。可以做反向代理的软件很多，比较常见的一种是Nginx。 Nginx是一种非常灵活的反向代理软件，可以自由定制化转发策略，分配服务器流量的权重等。反向代理中，常见的一个问题，就是Web服务器存储的session数据，因为一般负载均衡的策略都是随机分配请求的。同一个登录用户的请求，无法保证一定分配到相同的Web机器上，会导致无法找到session的问题。 解决方案主要有两种： 配置反向代理的转发规则，让同一个用户的请求一定落到同一台机器上（通过分析cookie），复杂的转发规则将会消耗更多的CPU，也增加了代理服务器的负担。 将session这类的信息，专门用某个独立服务来存储，例如redis/memchache，这个方案是比较推荐的。反向代理服务，也是可以开启缓存的，如果开启了，会增加反向代理的负担，需要谨慎使用。这种负载均衡策略实现和部署非常简单，而且性能表现也比较好。但是，它有“单点故障”的问题，如果挂了，会带来很多的麻烦。而且，到了后期Web服务器继续增加，它本身可能成为系统的瓶颈。 特性调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。 对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。 反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。 反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。 三、IP负载均衡(LVS-NAT)因为反向代理服务器工作在HTTP层，其本身的开销就已经严重制约了可扩展性，从而也限制了它的性能极限。那能否在HTTP层面以下实现负载均衡呢？答案当然是能。IP负载均衡服务是工作在网络层（修改IP）和传输层（修改端口，第四层），比起工作在应用层（第七层）性能要高出非常多。原理是，他是对IP层的数据包的IP地址和端口信息进行修改，达到负载均衡的目的。这种方式，也被称为“四层负载均衡”。常见的负载均衡方式，是LVS（Linux Virtual Server，Linux虚拟服务），通过IPVS（IP Virtual Server，IP虚拟服务）来实现。 在负载均衡服务器收到客户端的IP包的时候，会修改IP包的目标IP地址或端口，然后原封不动地投递到内部网络中，数据包会流入到实际Web服务器。实际服务器处理完成后，又会将数据包投递回给负载均衡服务器，它再修改目标IP地址为用户IP地址，最终回到客户端。 上述的方式叫LVS-NAT，除此之外，还有LVS-DR（直接路由），LVS-TUN（IP隧道），三者之间都属于LVS的方式，但是有一定的区别。 IP负载均衡的性能要高出Nginx的反向代理很多，它只处理到传输层为止的数据包，并不做进一步的组包，然后直接转发给实际服务器。不过，它的配置和搭建比较复杂。 实验证明使用基于NAT的负载均衡系统，作为调度器的NAT服务器可以将吞吐率提升到一个新的高度，几乎是反向代理服务器的两倍以上，这大多归功于在内核中进行请求转发的较低开销。但是一旦请求的内容过大时，不论是基于反向代理还是NAT，负载均衡的整体吞吐量都差距不大，这说明对于一睦开销较大的内容，使用简单的反向代理来搭建负载均衡系统是值考虑的。 这么强大的系统还是有它的瓶颈，那就是NAT服务器的网络带宽，包括内部网络和外部网络。当然如果你不差钱，可以去花钱去购买千兆交换机或万兆交换机，甚至负载均衡硬件设备，但如果你是个屌丝，咋办？ 一个简单有效的办法就是将基于NAT的集群和前面的DNS混合使用，比如５个100Mbps出口宽带的集群，然后通过DNS来将用户请求均衡地指向这些集群，同时，你还可以利用DNS智能解析实现地域就近访问。这样的配置对于大多数业务是足够了，但是对于提供下载或视频等服务的大规模站点，NAT服务器还是不够出色。 四、直接路由(LVS-DR)NAT是工作在网络分层模型的传输层（第四层），而直接路由是工作在数据链路层（第二层），貌似更屌些。它通过修改数据包的目标MAC地址（没有修改目标IP），将数据包转发到实际服务器上，不同的是，实际服务器的响应数据包将直接发送给客户羰，而不经过调度器。 LVS-DR 相较于LVS-NAT的最大优势在于LVS-DR不受调度器宽带的限制，例如假设三台服务器在WAN交换机出口宽带都限制为10Mbps，只要对于连接调度器和两台实际服务器的LAN交换机没有限速，那么，使用LVS-DR理论上可以达到20Mbps的最大出口宽带，因为它的实际服务器的响应数据包可以不经过调度器而直接发往用户端啊，所以它与调度器的出口宽带没有关系，只能自身的有关系。而如果使用LVS-NAT，集群只能最大使用10Mbps的宽带。所以，越是响应数据包远远超过请求数据包的服务，就越应该降低调度器转移请求的开销，也就越能提高整体的扩展能力，最终也就越依赖于WAN出口宽带。 总的来说，LVS-DR适合搭建可扩展的负载均衡系统，不论是Web服务器还是文件服务器，以及视频服务器，它都拥有出色的性能。前提是你必须为实际器购买一系列的合法IP地址。 五、IP隧道(LVS-TUN)基于IP隧道的请求转发机制：将调度器收到的IP数据包封装在一个新的IP数据包中，转交给实际服务器，然后实际服务器的响应数据包可以直接到达用户端。目前Linux大多支持，可以用LVS来实现，称为LVS-TUN，与LVS-DR不同的是，实际服务器可以和调度器不在同一个WANt网段，调度器通过 IP隧道技术来转发请求到实际服务器，所以实际服务器也必须拥有合法的IP地址。 总体来说，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可以将实际服务器根据需要部署在不同的地域，并且根据就近访问的原则来转移请求，所以有类似这种需求的，就应该选择LVS-TUN。 六、DNS负载均衡DNS（Domain Name System）负责域名解析的服务，域名url实际上是服务器的别名，实际映射是一个IP地址，解析过程，就是DNS完成域名到IP的映射。而一个域名是可以配置成对应多个IP的。因此，DNS也就可以作为负载均衡服务。 这种负载均衡策略，配置简单，性能极佳。但是，不能自由定义规则，而且，变更被映射的IP或者机器故障时很麻烦，还存在DNS生效延迟的问题。 特性可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。 动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。 七、DNS/GSLB负载均衡我们常用的CDN（Content Delivery Network，内容分发网络）实现方式，其实就是在同一个域名映射为多IP的基础上更进一步，通过GSLB（Global Server Load Balance，全局负载均衡）按照指定规则映射域名的IP。一般情况下都是按照地理位置，将离用户近的IP返回给用户，减少网络传输中的路由节点之间的跳跃消耗。 CDN在Web系统中，一般情况下是用来解决大小较大的静态资源（html/Js/Css/图片等）的加载问题，让这些比较依赖网络下载的内容，尽可能离用户更近，提升用户体验。 这种方式，和前面的DNS负载均衡一样，不仅性能极佳，而且支持配置多种策略。但是，搭建和维护成本非常高。互联网一线公司，会自建CDN服务，中小型公司一般使用第三方提供的CDN。 参考http://developer.51cto.com/art/201410/454951.htmhttp://blog.jobbole.com/91738/http://www.open-open.com/lib/view/open1416924842581.htmlhttp://voidy.net/web_load_balance","tags":[{"name":"Web服务器","slug":"webserver","permalink":"http://blog.inbelieve.top/tags/webserver/"}]},{"title":"Nginx中巧用return来测试","date":"2018-06-17T09:20:35.000Z","path":"server/20180617-5.html","text":"最近用到一个项目部署到服务器上，发现在nginx上配置proxy_pass之后请求参数丢失了，查询了很久一直没找到原因，后来使用nginx中return，把参数打印出来，这样成功解决了问题。 返回状态码 nginx 配置如下：location = /test &#123; return 403 ;&#125; 通过返回的页面为： 403 Forbidden 正常的403错误返回码报错 返回 文本信息和json location ^~ /pic &#123; default_type text/html ; return 200 &apos;hello world! &apos;;&#125;location ^~ /pic &#123; default_type application/json ; return 200 &apos;&#123;&quot;name&quot;:&quot;nanjing_wuxu&quot;,&quot;result&quot;:&quot;success&quot;&#125;&apos;;&#125; 直接跳转功能 location ^~ /pic &#123; return http://192.168.1.19/test.jpg;&#125; 直接返回$queryString, $document_root $fastcgi_path_info location ^~ /pic &#123;location ~ \\.php(.*)$ &#123; default_type text/html ; return 200 $document_root;&#125;location ^~ /pic &#123;location ~ \\.php(.*)$ &#123; default_type text/html ; return 200 $fastcgi_path_info;&#125;location ^~ /pic &#123;location ~ \\.php(.*)$ &#123; default_type text/html ; return 200 $queryString;&#125; 以上你可以通过nginx的return功能来做确认转发之前是否已经把所有信息都转发了","tags":[{"name":"Web服务器","slug":"webserver","permalink":"http://blog.inbelieve.top/tags/webserver/"},{"name":"Nginx","slug":"nginx","permalink":"http://blog.inbelieve.top/tags/nginx/"}]},{"title":"比较Cookie Session localStorage sessionStorage之区别","date":"2018-06-17T09:13:42.000Z","path":"frontend/20180617-4.html","text":"今天在做Vue的项目时，遇到一个关于存储数据list的问题，最初打算是放在Vuex中，但发现一旦刷新页面就消失了，必须重新请求。于是，我又想了下把list存储在cookie里，发现cookie又有大小限制，而放在localStorage中又会一直存在，必须手动清除，最后选择了sessionStorage中。发现原来还有这样的几种不同的方式，这里就对现有的cookie,session,localstorage,sessionstorage进行分析下： cookie和session都是用来跟踪浏览器用户身份的会话方式。区别：1、保持状态： cookie保存在浏览器端 session保存在服务器端 2、使用方式： cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。 Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它 session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。 3、存储内容： cookie只能保存字符串类型，以文本的方式 session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象) 4、存储的大小： cookie：单个cookie保存的数据不能超过4kb； session大小没有限制。 5、安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。原因如下： sessionID存储在cookie中，若要攻破session首先要攻破cookie； sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID； 第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。 sessionID是加密的 6、缺点： cookie： - 大小受限- 用户可以操作（禁用）cookie，使功能受限- 安全性较低- 有些状态不可能保存在客户端。- 每次访问都要传送cookie给服务器，浪费带宽。- cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。 session： - Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。- 依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全 WebStorageWebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。 WebStorage两个主要目标： 提供一种在cookie之外存储会话数据的路径。 提供一种存储大量可以跨会话存在的数据的机制。 HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage(会话存储）,以下从各个方面来比较区别 1、生命周期： localStorage: localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。 sessionStorage sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。 2、存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB 3、存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。 4、存储内容类型：localStorage和sessionStorage只能存储字符串类型 5、获取方式： localStorage：window.localStorage sessionStorage：window.sessionStorage 6、应用场景： localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。-sessionStorage：敏感账号一次性登录； WebStorage的优点： 存储空间更大：cookie为4KB，而WebStorage是5MB； 节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量； 对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便； 快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快； 安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题； WebStorage提供了一些方法，数据操作比cookie方便； setItem (key, value) —— 保存数据，以键值对的方式储存信息。getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。removeItem (key) —— 删除单个数据，根据键值移除对应的信息。clear () —— 删除所有的数据key (index) —— 获取某个索引的key","tags":[{"name":"JavaScript","slug":"javascript","permalink":"http://blog.inbelieve.top/tags/javascript/"},{"name":"HTML5","slug":"html5","permalink":"http://blog.inbelieve.top/tags/html5/"}]},{"title":"mysql之慢查询","date":"2018-06-17T09:13:08.000Z","path":"server/20180617-3.html","text":"定位慢查询sql语句可以通过开启慢查询来将所有的慢查询记录到某个文件里面，这里以slow-query.log为例 方式一:通过工具分析MySQL自带了mysqldumpslow工具用来分析slow query日志，除此之外，还有一些好用的开源工具。比如MyProfi、mysql-log-filter，当然还有mysqlsla等 以下是mysqldumpslow常用参数说明，详细的可应用mysqldumpslow -help查询。 -s，是表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序（从大到小），ac、at、al、ar表示相应的倒叙。 -t，是top n的意思，即为返回前面多少条数据。 -g，后边可以写一个正则匹配模式，大小写不敏感。 接下来就是用mysql自带的慢查询工具mysqldumpslow分析了（mysql的bin目录下），我这里的日志文件名字是slow-query.log。 列出记录次数最多的10个sql语句mysqldumpslow -s c -t 10 slow-query.log 列出返回记录集最多的10个sql语句mysqldumpslow -s r -t 10 slow-query.log 按照时间返回前10条里面含有左连接的sql语句mysqldumpslow -s t -t 10 -g &quot;left join&quot; slow-query.log 使用mysqldumpslow命令可以非常明确的得到各种我们需要的查询语句，对MySQL查询语句的监控、分析、优化起到非常大的帮助。 方式二:直接分析mysql慢查询日志Time Id Command Argument# Time: 180419 10:17:15# User@Host: root[root] @ localhost [::1]# Thread_id: 2 Schema: QC_hit: No# Query_time: 3.018396 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0# Rows_affected: 0SET timestamp=1524104235;SELECT `h_room_item`.`id`, `h_room_item`.`num`, `h_room_item`.`code`, `h_order`.`ord_no`, `h_order`.`stat`, `h_order`.`sex`, `h_order`.`end_dat`, `h_order`.`start_dat`, `h_item_flag`.`flag_id` FROM `h_room_item` LEFT JOIN `h_item_flag` ON h_item_flag.room_id=h_room_item.id LEFT JOIN `h_order` ON h_order.room_no=h_room_item.num and h_order.code=h_room_item.code WHERE (`h_room_item`.`code`=&apos;qt001&apos;) AND (`h_item_flag`.`flag_id` IN (&apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;9&apos;, &apos;17&apos;, &apos;18&apos;, &apos;19&apos;, &apos;20&apos;, &apos;21&apos;)) ORDER BY `h_room_item`.`id` LIMIT 24; 使用desc或者explain来分析sql语句desc SELECT `h_room_item`.`id`, `h_room_item`.`num`, `h_room_item`.`code`, `h_order`.`ord_no`, `h_order`.`stat`, `h_order`.`sex`, `h_order`.`end_dat`, `h_order`.`start_dat`, `h_item_flag`.`flag_id` FROM `h_room_item` LEFT JOIN `h_item_flag` ON h_item_flag.room_id=h_room_item.id LEFT JOIN `h_order` ON h_order.room_no=h_room_item.num and h_order.code=h_room_item.code WHERE (`h_room_item`.`code`=&apos;qt001&apos;) AND (`h_item_flag`.`flag_id` IN (&apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;9&apos;, &apos;17&apos;, &apos;18&apos;, &apos;19&apos;, &apos;20&apos;, &apos;21&apos;)) ORDER BY `h_room_item`.`id` LIMIT 24\\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: h_item_flag type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 28 Extra: Using where; Using temporary; Using filesort*************************** 2. row *************************** id: 1 select_type: SIMPLE table: h_room_item type: eq_refpossible_keys: PRIMARY,index2 key: PRIMARY key_len: 4 ref: hotel_door.h_item_flag.room_id rows: 1 Extra: Using where*************************** 3. row *************************** id: 1 select_type: SIMPLE table: h_order type: ALLpossible_keys: index3 key: NULL key_len: NULL ref: NULL rows: 10 Extra: Using where; Using join buffer (flat, BNL join)3 rows in set (0.60 sec) 可能原因： 1、没有索引或者没有用到索引(这是查询慢最常见的问题，是程序设计的缺陷) 2、I/O吞吐量小，形成了瓶颈效应。 3、没有创建计算列导致查询不优化。 4、内存不足 5、网络速度慢 6、查询出的数据量过大(可以采用多次查询，其他的方法降低数据量) 7、锁或者死锁(这也是查询慢最常见的问题，是程序设计的缺陷) 8、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。 9、返回了不必要的行和列 10、查询语句不好，没有优化","tags":[{"name":"MySQL","slug":"mysql","permalink":"http://blog.inbelieve.top/tags/mysql/"}]},{"title":"慢查询原因总结","date":"2018-06-17T09:10:38.000Z","path":"skill/20180617-1.html","text":"定位慢查询sql语句可以通过开启慢查询来将所有的慢查询记录到某个文件里面，这里以slow-query.log为例 方式一:通过工具分析MySQL自带了mysqldumpslow工具用来分析slow query日志，除此之外，还有一些好用的开源工具。比如MyProfi、mysql-log-filter，当然还有mysqlsla等 以下是mysqldumpslow常用参数说明，详细的可应用mysqldumpslow -help查询。 -s，是表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序（从大到小），ac、at、al、ar表示相应的倒叙。 -t，是top n的意思，即为返回前面多少条数据。 -g，后边可以写一个正则匹配模式，大小写不敏感。 接下来就是用mysql自带的慢查询工具mysqldumpslow分析了（mysql的bin目录下），我这里的日志文件名字是slow-query.log。 列出记录次数最多的10个sql语句mysqldumpslow -s c -t 10 slow-query.log 列出返回记录集最多的10个sql语句mysqldumpslow -s r -t 10 slow-query.log 按照时间返回前10条里面含有左连接的sql语句mysqldumpslow -s t -t 10 -g &quot;left join&quot; slow-query.log 使用mysqldumpslow命令可以非常明确的得到各种我们需要的查询语句，对MySQL查询语句的监控、分析、优化起到非常大的帮助。 方式二:直接分析mysql慢查询日志Time Id Command Argument# Time: 180419 10:17:15# User@Host: root[root] @ localhost [::1]# Thread_id: 2 Schema: QC_hit: No# Query_time: 3.018396 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0# Rows_affected: 0SET timestamp=1524104235;SELECT `h_room_item`.`id`, `h_room_item`.`num`, `h_room_item`.`code`, `h_order`.`ord_no`, `h_order`.`stat`, `h_order`.`sex`, `h_order`.`end_dat`, `h_order`.`start_dat`, `h_item_flag`.`flag_id` FROM `h_room_item` LEFT JOIN `h_item_flag` ON h_item_flag.room_id=h_room_item.id LEFT JOIN `h_order` ON h_order.room_no=h_room_item.num and h_order.code=h_room_item.code WHERE (`h_room_item`.`code`=&apos;qt001&apos;) AND (`h_item_flag`.`flag_id` IN (&apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;9&apos;, &apos;17&apos;, &apos;18&apos;, &apos;19&apos;, &apos;20&apos;, &apos;21&apos;)) ORDER BY `h_room_item`.`id` LIMIT 24; 使用desc或者explain来分析sql语句desc SELECT `h_room_item`.`id`, `h_room_item`.`num`, `h_room_item`.`code`, `h_order`.`ord_no`, `h_order`.`stat`, `h_order`.`sex`, `h_order`.`end_dat`, `h_order`.`start_dat`, `h_item_flag`.`flag_id` FROM `h_room_item` LEFT JOIN `h_item_flag` ON h_item_flag.room_id=h_room_item.id LEFT JOIN `h_order` ON h_order.room_no=h_room_item.num and h_order.code=h_room_item.code WHERE (`h_room_item`.`code`=&apos;qt001&apos;) AND (`h_item_flag`.`flag_id` IN (&apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;9&apos;, &apos;17&apos;, &apos;18&apos;, &apos;19&apos;, &apos;20&apos;, &apos;21&apos;)) ORDER BY `h_room_item`.`id` LIMIT 24\\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: h_item_flag type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 28 Extra: Using where; Using temporary; Using filesort*************************** 2. row *************************** id: 1 select_type: SIMPLE table: h_room_item type: eq_refpossible_keys: PRIMARY,index2 key: PRIMARY key_len: 4 ref: hotel_door.h_item_flag.room_id rows: 1 Extra: Using where*************************** 3. row *************************** id: 1 select_type: SIMPLE table: h_order type: ALLpossible_keys: index3 key: NULL key_len: NULL ref: NULL rows: 10 Extra: Using where; Using join buffer (flat, BNL join)3 rows in set (0.60 sec) 可能原因： 1、没有索引或者没有用到索引(这是查询慢最常见的问题，是程序设计的缺陷) 2、I/O吞吐量小，形成了瓶颈效应。 3、没有创建计算列导致查询不优化。 4、内存不足 5、网络速度慢 6、查询出的数据量过大(可以采用多次查询，其他的方法降低数据量) 7、锁或者死锁(这也是查询慢最常见的问题，是程序设计的缺陷) 8、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。 9、返回了不必要的行和列 10、查询语句不好，没有优化","tags":[{"name":"MySQL","slug":"mysql","permalink":"http://blog.inbelieve.top/tags/mysql/"}]},{"title":"读汪国真的诗","date":"2018-06-17T08:07:56.000Z","path":"life/20180617-0.html","text":"最近在箱子里收拾下东西，翻到了以前的一本笔记本，拿来看一下，发现是以前读过并抄下来的诗歌，其中几首是汪国真的诗歌，他的诗歌总是充满了阳光和青春，读他的诗总能体会到青春的味道。下面我把他们贴出来 ####《热爱生命》我不去想是否能够成功既然选择了远方便只顾风雨兼程我不去想能否赢得爱情既然钟情于玫瑰就勇敢地吐露真诚我不去想身后会不会袭来寒风冷雨既然目标是地平线留给世界的只能是背影我不去想未来是平坦还是泥泞只要热爱生命一切，都在意料之中 ####《感谢》 让我怎样感谢你当我走向你的时候我原想收获一缕春风你却给了我整个春天让我怎样感谢你当我走向你的时候我原想捧起一簇浪花你却给了我整个海洋让我怎样感谢你当我走向你的时候我原想撷取一枚红叶你却给了我整个枫林让我怎样感谢你当我走向你的时候我原想亲吻一朵雪花你却给了我银色的世界 ####《学会等待》 不要因为一次的失败就打不起精神，每个成功的人背后都有苦衷。你看即便像太阳那样辉煌，有时也被浮云遮住了光阴。你的才华不会永远被埋没，除非你自己想把前途葬送。你要学会等待和安排自己，成功其实不需要太多酒精。要当英雄不妨先当狗熊，怕只怕对什么都无动于衷。河上没有桥还可以等待结冰，走过漫长的黑夜便是黎明。 ####《嫁给幸福》 有一个未来的目标总能让我们欢欣鼓舞就像飞向火光的灰蛾甘愿做烈焰的俘虏摆动着的是你不停的脚步飞旋着的是你美丽的流苏在一往情深的日子里谁能说得清什么是甜 什么是苦只知道 确定了就义无返顾要输就输给追求要嫁就嫁给幸福","tags":[{"name":"诗歌","slug":"peomtry","permalink":"http://blog.inbelieve.top/tags/peomtry/"}]},{"title":"心有猛虎，细嗅蔷薇","date":"2018-06-17T07:36:25.000Z","path":"life/20180617-2.html","text":"In me, past, present, future meet，于我，过去、现在和未来 To hold long chiding conference.商讨聚会 各执一词 纷扰不息。 My lusts usurp the present tense林林总总的 欲望，掠取着我的现在 And strangle Reason in his seat. 把“理性”扼杀于它的宝座 My loves leap through the future’s fence我的爱情纷纷越过未来的藩篱 To dance with dream-enfranchised feet.梦想解放出它们的双脚 舞蹈不停 In me the cave-man clasps the seer,于我，穴居人攫取了先知， And garlanded Apollo goes 佩戴花环的阿波罗神 Chanting to Abraham’s deaf ear.向亚伯拉罕的聋耳唱叹歌吟。 In me the tiger sniffs the rose.心有猛虎，细嗅蔷薇。 Look in my heart, kind friends, and tremble,审视我的内心吧，亲爱的朋友，你应颤栗， Since there your elements assemble.因为那才是你本来的面目。","tags":[{"name":"诗歌","slug":"peomtry","permalink":"http://blog.inbelieve.top/tags/peomtry/"}]},{"title":"更改pip源为国内镜像地址","date":"2018-06-16T09:31:09.000Z","path":"server/20180616-7.html","text":"经常在使用python的时候需要安装各种模块，而pip是很强大的模块安装工具，但是由于国外官方pypi经常被墙，导致不可用，所以我们最好是将自己使用的pip源更换一下，这样就能解决被墙导致的装不上库的烦恼。 修改源以ubuntu16.04为例进行说明。 国内源（新版ubuntu要求使用https源，要注意。）： 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣：http://pypi.douban.com/simple/ 还有一些别的没有列出。 临时使用：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider 永久修改： Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)，内容如下： [global] index-url = http://mirrors.aliyun.com/pypi/simple/ [install] trusted-host=mirrors.aliyun.com timeout = 150 # 超时时间设置(单位为s)，一般可以设置的长一些 windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下: [global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple","tags":[{"name":"Python","slug":"python","permalink":"http://blog.inbelieve.top/tags/python/"}]},{"title":"centos7上安装nginx+uwsgi搭建项目","date":"2018-06-16T09:30:48.000Z","path":"server/20180616-6.html","text":"*安装nginxyum instal nginx 使用pip安装uwsgi pip install uwsgi 新建配置文件 mkdir /etc/uwsgivim /etc/uwsgi/uwsgi.ini 配置uwsgi [uwsgi]socket = 127.0.0.1:9090master = true wsgi-file=/var/www/html/python/test.py#vhost = true no-site = true workers = 2 reload-mercy = 10 vacuum = true max-requests = 1000 limit-as = 512buffer-size = 30000pidfile = /var/run/uwsgi9090.pid daemonize = /var/log/uwsgi9090.log 配置test.py文件 mkdir /var/www/html/python/vim test.py 写文件def application(env, start_response): start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;,&apos;text/html&apos;)]) return &quot;Hello World&quot; 配置nginxvim /etc/nginx/conf.d/python.conf 插入下面server &#123; listen 8090; server_name 127.0.0.1; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:9090; &#125;&#125; 启动 systemctl start nginxuwsgi /etc/uwsgi/uwsgi.ini 访问,在浏览器上输入10.104.15.150:9090（此时ip换成你的linux机器ip） 1524623005.jpg 如此，则成功了，接下来你可以愉快地使用python进行项目开发了","tags":[{"name":"Linux","slug":"linux","permalink":"http://blog.inbelieve.top/tags/linux/"},{"name":"Centos","slug":"centos","permalink":"http://blog.inbelieve.top/tags/centos/"},{"name":"Python","slug":"python","permalink":"http://blog.inbelieve.top/tags/python/"}]},{"title":"启动docker服务找不到group docker报错处理","date":"2018-06-16T09:30:22.000Z","path":"server/20180616-5.html","text":"最近在安装docker时发现，启动docker服务时发现提示下面的出错信息could not change group /var/run/docker.sock to docker: group docker not found 后来查了一下原因，发现这是因为cgroup没有挂载的原因，只要把cgroup挂载好就OK了，挂载方法如下vim /etc/fstab#在最后一行增加以下配置信息：none /sys/fs/cgroup cgroup defaults 0 0 保存退出，在启动试一下systemctl start dockerifconfig 发现docker服务已经成功跑起来了","tags":[{"name":"Docker","slug":"docker","permalink":"http://blog.inbelieve.top/tags/docker/"}]},{"title":"docker基本命令详解","date":"2018-06-16T09:29:41.000Z","path":"server/20180616-4.html","text":"attach: 将标准输入（stdin）与标准输出（stdout）连接到正在运行的容器 docker attach [OPTIONS] CONTAINER# 创建容器docker create -it --name centos-container centos /bin/bash# 若想使用刚刚创建的容器，则必须使用docker start 命令启动容器docker start centos-container# 进入容器内部docker attach centos-container build: 使用Dockerfile文件创建镜像 docker build &lt;选项&gt;&lt;Dockerfile路径&gt; commit: 从容器的修改项创建显得镜像 docker commit &lt;选项&gt;&lt;容器名称，id&gt;/&lt;镜像名称&gt;:&lt;标签&gt; cp: 用于将容器的目录或文件复制的到主机。若将cp命令中的路径设置为目录，则将该目录下的所有内容复制到主机 docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH# 将容器内的整个/etc 目录复制到主机当前文件夹下docker cp centos-container:/etc /home/long create: 使用指定的镜像创建容器。与run命令不同，使用create命令只能创建容器而并不启动 docker create [OPTIONS] IMAGE [COMMAND] [ARG...]# 创建容器docker create -it --name centos-container centos /bin/bash# 若想使用刚刚创建的容器，则必须使用docker start 命令启动容器docker start centos-container# 进入容器内部docker attach centos-container# 退出容器exit# 停止容器docker stop centos-container diff: 检查容器文件系统的修改(查看修改内容) docker diff &lt;容器名称，id&gt;# 示例[root@localhost /home/long]# docker diff centos-containerC /runA /run/secretsC /rootA /root/.bash_history events: 实时输出Docker服务器中发生的事件 docker events另一终端，运行容器docker start centos-container此端输出2018-04-26T19:16:35.017678507-07:00 network connect b2376bcc00f587966645b362992289aa78ea58080ea6713a9a418b5f82e64c48 (container=24d1711909362e7620f9c76f266a671f1a7336452e88ff32c4942a4768801d79, name=bridge, type=bridge)2018-04-26T19:16:35.622752724-07:00 container start 24d1711909362e7620f9c76f266a671f1a7336452e88ff32c4942a4768801d79 (build-date=20170911, image=centos, license=GPLv2, name=centos-container, vendor=CentOS) exec: 用于从外部运行容器内部的命令 docker exec [OPTIONS] CONTAINER COMMAND [ARG...]# 执行docker exec -it hello /bin/bashps -ef export: 将容器的文件系统导出为tar文件包 docker export &lt;容器名称，id&gt;# 示例docker export centos-container &gt; centos-container.tar history: 显示镜像的历史。此处的历史依据Dockerfile文件中的设置创建。 docker history &lt;选项&gt;&lt;镜像名称，id&gt;# 示例[root@localhost /home/long]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/tomcat latest 33e02377a00f 2 weeks ago 553.8 MBdocker.io/nginx latest b175e7467d66 2 weeks ago 108.9 MBdocker.io/centos latest 196e0ce0c9fb 7 months ago 196.6 MB[root@localhost /home/long]# docker history tomcat images: 查看所有镜像 [root@localhost /home/long]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/tomcat latest 33e02377a00f 2 weeks ago 553.8 MBdocker.io/nginx latest b175e7467d66 2 weeks ago 108.9 MBdocker.io/centos latest 196e0ce0c9fb 7 months ago 196.6 MB import: 从压缩为tar文件（.tar .tar.gz .tgz .bzip .tar.xz .txz）的文件系统创建镜像 docker import &lt;tar文件的URL或者 - &gt;&lt;注册名称&gt;/&lt;镜像名称&gt;:&lt;标签&gt;docker import centos-container.tar centos-container-2cat centos-container | docker import - centos-container-2 info: 显示当前系统信息、docker容器、镜像个数、设置等信息 docker info inspect: 获得更详细的容器、镜像或者任务信息 docker inspect &lt;选项&gt;&lt;容器或镜像名称，id&gt;# 示例docker inspect centos-container kill: 向容器发送KILL信号，从而关闭容器（推荐使用更优雅温和的 docker stop 命令) docker kill centos-container load: 从tar文件或标准输入中创建镜像 docker load &lt;选项&gt;# 示例docker load -i centos-container.tar login: 登录Docker 的注册服务器,若不设置注册服务器的地址，则默认登录dockerhub docker login &lt;选项&gt;&lt;Docker 注册服务器的URL&gt;-e、--email=&quot;&quot; 设置登录时使用的电子邮件-p、--password=&quot;&quot; 设置登录密码-u、--username=&quot;&quot; 设置登录时使用的账号 logout: 从Docker注册服务器中登出 docker logout &lt;选项&gt;&lt;Docker 注册服务器的URL&gt; logs: 获取容器日志 docker logs &lt;容器名称，id&gt;# 示例docker logs centos-container network: 管理docker的网络系统 docker network COMMAND# 示例docker network ls node: 管理docker的swarm集群节点 docker node ls pause: 暂停容器中所有的进程（可以是多个容器） docker pause &lt;容器名称，id&gt;# 示例docker pause centos-container# 恢复docker unpause centos-container port: 查看容器的某个端口是否处于开放状态 docker port &lt;容器名称，id&gt;&lt;端口&gt;# 示例docker port centos-container 8090 ps: 查看容器列表 docker ps &lt;选项&gt;-a、--all=false 列出所有容器。不带 -a 只输出在运行的容器--before=&quot;&quot; 列出特定容器创建前的容器，包含停止的容器。-f、--filter=[] 设置输出过滤。如 &quot;exited=0&quot;-l、--latest=false 列出最后创建的容器，包含停止的容器-q、--quiet=false 只输出容器的id# 示例docker ps -a pull: 从一个远程仓库拉取镜像 docker pull &lt;选项&gt; &lt;镜像名&gt;:&lt;标签&gt;# 示例docker pull nginx:latest push: 将镜像推送到Docker注册服务器或者指定仓库 docker push &lt;注册名&gt;/&lt;镜像名&gt;:&lt;标签&gt;docker pull 192.168.1.150:10000/centos-container:latest rename: 修改某一个容器名字 docker rename &lt;容器名&gt; &lt;新容器名&gt;# 示例 docker rename centos-container centos restart: 重启容器 docker restart &lt;容器名称，id&gt;docker restart centos-container rm: 删除容器 docker rm &lt;容器名称，id&gt;# 示例docker ps -adocker rm hellodocker ps -a rmi: 删除镜像, 若不指定标签，则删除latest标签 docker rmi &lt;注册名称&gt;/&lt;镜像名称，id&gt;:&lt;标签&gt;# 示例docker imagesdocker nginxdocker images run: 使用命令行指定镜像创建容器 docker run &lt;选项&gt;&lt;镜像名称，id&gt;&lt;命令&gt;&lt;参数&gt;# 示例docker ps -adocker run --name hello -i -t centos /bin/bashdocker ps -a save: 将镜像保存为tar包文件 docker save &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;# 示例[root@localhost /home/long]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/tomcat latest 33e02377a00f 2 weeks ago 553.8 MBdocker.io/nginx latest b175e7467d66 2 weeks ago 108.9 MBdocker.io/centos latest 196e0ce0c9fb 7 months ago 196.6 MB[root@localhost /home/long]# docker save nginx -o nginx.tar[root@localhost /home/long]# lltotal 110028drwxr-xr-x. 2 long long 6 Sep 28 2017 Desktopdrwxr-xr-x. 2 long long 6 Sep 28 2017 Documentsdrwxr-xr-x. 2 long long 6 Sep 28 2017 Downloadsdrwxr-xr-x. 2 long long 6 Sep 28 2017 Music-rw-------. 1 root root 112667648 Apr 26 22:46 nginx.tar #生成了新的文件drwxr-xr-x. 2 long long 6 Sep 28 2017 Picturesdrwxr-xr-x. 2 long long 6 Sep 28 2017 Publicdrwxr-xr-x. 2 long long 61 Oct 17 2017 sambadrwxr-xr-x. 2 long long 6 Sep 28 2017 Templatesdrwxr-xr-x. 2 long long 6 Sep 28 2017 Videos[root@localhost /home/long]# search: 根据名字在docker hub搜索你要的镜像 docker search &lt;选项&gt;&lt;搜索词&gt;--automated=false 只显示由docker hub 的automated build 创建的镜像--no-trunc=false 显示所有因因为内容过长而省略的部分-s、--stars=0 显示滴啊有特定星级以上的镜像# 示例docker search nginx service: 管理docker服务 docker service [COMMAND]docker service ls #主要用于swarm集群 start: 启动一个或多个容器 docker start &lt;选项&gt;&lt;容器名称，id&gt;# 示例docker start centos-container stats: 显示一个容器的使用资源情况，包括cpu，内存，硬盘等 docker stats &lt;选项&gt;&lt;容器名称，id&gt;# 示例docker stats centos-container stop: 停止容器 docker stop&lt;选项&gt;&lt;容器或镜像名称，id&gt;# 示例docker stop centos-container swarm: 管理Docker Swarm集群 docker swarm [COMMAND]# 初始化一个swarm集群docker swarm init tag: 标记本地镜像，将其归入某一仓库 docker tag &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;&lt;注册地址，用户名&gt;/&lt;镜像名称&gt;:&lt;标签&gt;#示例docker tag nginx:latest youset:6666/nginx:0.1 top: 显示容器中正在运行的进程信息 docker top &lt;容器名称，id&gt;&lt;ps选项&gt;#示例docker top centos-container unpause: 停止容器内的所有进程 docker unpause &lt;容器名称，id&gt;#示例docker unpause centos-container update: 动态地更新容器配置。可以使用这个命令限制容器在docker主机上使用太多的资源 docker update &lt;容器名称，id&gt;#示例doucker update centos-container version: 展示docker版本信息 [root@localhost /home/long]# docker versionClient: Version: 1.12.6 API version: 1.24 Package version: docker-1.12.6-55.gitc4618fb.el7.centos.x86_64 Go version: go1.8.3 Git commit: c4618fb/1.12.6 Built: Thu Sep 21 22:33:52 2017 OS/Arch: linux/amd64Server: Version: 1.12.6 API version: 1.24 Package version: docker-1.12.6-55.gitc4618fb.el7.centos.x86_64 Go version: go1.8.3 Git commit: c4618fb/1.12.6 Built: Thu Sep 21 22:33:52 2017 OS/Arch: linux/amd64 volume: 管理docker数据卷 docker volume [COMMAND]# 示例docker volume ls wait: 等待容器终止，然后输出 Exit Code docker wait &lt;容器名称，id&gt;# 示例docker wait centos-container 以上就是docker的主要命令，包括docker swarm集群的一些命令，除此之外还有一些其他的命令,如下：--api-enable-cors=false 使用API时，启用CORS（cross-origin resource sharing）-b 、--bridge=&quot;&quot; 使用事先创建的网桥接口。若设置为none，则不在容器内使用网络--bip=&quot;&quot; 使用CIDR标记法设置docker 的IP带宽。该选项不能与-b选项同时使用如：`-bip=&quot;192.168.0.0/24&quot;`-D 、--debug 启用调试模式-d 、--deamon=false 以守护进程模式运行--dns 设置docker要使用的DNS服务器--dns-search=[] 设置docker要使用的DNS搜索域。若设置为：example.com，则向服务器查询hello时，将首先查找hello.example.com-e、--exec-drive=&quot;native&quot; 设置docker运行驱动，可设置为Native与lxc--fixed-cidr=&quot;&quot; 固定分配IPv4地址的带宽。该IP地址必须在-b选项设置的网桥网络或--bip设置的IP网段内-G、--group=&quot;docker&quot; 以守护进程模式运行时，使用-H选项创建Unix套接字后，设置该Unix套接字所在的组。使用&quot;&quot;空字符串表示不设置分组-g、 --graph=&quot;/var/lib/docker&quot; 设置docker使用目录的顶层路径-H、--host[] 以守护进程模式运行时，设置套接字路径。--icc=true 开启容器间通信--insecure-registry=[] 使用私有证书搭建docker注册服务器时，设置docker注册服务器域名--ip=0.0.0.0 使用docker run 命令时-p选项将端口暴露在外时，设置要绑定的默认IP地址--ip-forward=true 开启net.ipv4.ip_forward--ip-masq=true 为网桥上的IP地址开启IP伪装（masquerading）--iptables=true 开启iptables规则--mtu=0 设置容器的网络最大传输单元（MTU, Maxmum transmission unit）若不设置，则使用路由器的默认MTU或者设置为1500-p、--pidfile=&quot;/var/run/docker.pid&quot; 设置PID文件路径-registry-mirror=[] 设置docker registry 的镜像地址-s、--storage-driver=[] 设置储存驱动，默认为auto，也可以设置为drivcemapper--selinux-enabled=false开启SELinux SELinux尚不支持BTRFS储存驱动--storage-opt 设置存储驱动选项--tls=false 使用TLS--tlscacert=&quot;/home/exapmleuser/.docker/ca.pem&quot; 设置要在远程证书中使用的CA证书文件的路径--tlscert=&quot;/home/exapmleuser/.docker/cert.pem&quot; 设置证书文件路径--tlskey=&quot;/home/exapmleuser/.docker/key.pem&quot; 设置密匙文件路径tlsverify=&quot;false&quot; 使用TLS远程证书，守护进程与客户端全部使用证书验证-v、--version=false 打印版本信息 docker一个很有意思的东西，如果你还在纠结于每次装完软件后，要更新软件无法删除所有的文件时，你不妨考虑一下使用docker,他让你可以快速部署，快速清除，快捷方便。","tags":[{"name":"Docker","slug":"docker","permalink":"http://blog.inbelieve.top/tags/docker/"}]},{"title":"设置rubygems国内镜像地址","date":"2018-06-16T09:29:14.000Z","path":"server/20180616-3.html","text":"安装完ruby和rubygems后发现gem下载包很慢，这是因为gem的仓库地址是国外的原因。 我查了一下，发现国内有镜像https://gems.ruby-china.org/可以使用，现在我们来把它设置成国内镜像。 查看gem是否安装$ gem -v2.5.1 更换源地址$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -l*** CURRENT SOURCES ***https://gems.ruby-china.org/ SSL 证书错误正常情况下，你是不会遇到 SSL 证书错误的，除非你的 Ruby 安装方式不正确。 如果遇到 SSL 证书问题，你又无法解决，请修改 ~/.gemrc 文，增加 ssl_verify_mode: 0 配置，以便于 RubyGems 可以忽略 SSL 证书错误。 linux ---:sources:- https://gems.ruby-china.org:ssl_verify_mode: 0 windows下载 https://curl.haxx.se/ca/cacert.pem(这里我使用mingw64下载)把文件cacert.pem放到一个目录下 cd ~curl https://curl.haxx.se/ca/cacert.pem --silent -O 通过系统-&gt;高级系统设置-&gt;环境变量设置SSL_CERT_FILE,然后重新执行配置操作(关闭当前命令行在开)","tags":[{"name":"Ruby","slug":"ruby","permalink":"http://blog.inbelieve.top/tags/ruby/"}]},{"title":"关于竞争","date":"2018-06-16T09:28:43.000Z","path":"life/20180616-2.html","text":"昨夜，我2年来第一次熬夜看球赛，NBA骑士和步行者的抢七，这次系列赛可以说荡气回肠，从场均40多分钟上场时间，拼到流血的勒布朗·詹姆斯到即使到了最后一刻也不放弃的步行者，每一刻都充满了热血，充满了身体对抗，充满了竞争，我为了他们产生由衷的敬仰。 odzo-fzvpatr2859339.jpg 依然记得那年的步行者五虎和热火东部大战，而如今，步行者已经从格兰杰到保罗乔治，再到奥拉迪波，他们每场都打得很顽强，将身体一次次的抛向空中，倒地，站起来，退房。如果这个世界能代表无与伦比的竞争精神，我想这就是——不服输不认输，never give up. 骑士，这只千疮百孔的球队，这一夜梦回2016，詹姆斯腿抽筋继续战斗，被认为是八贤王的TT如同天神下凡吧，这种斗志，一步一步的拖着骑士前行。 步行者，被打散2次，重建2次，还是詹姆斯的对手，奥拉迪波，这个上年被称为毒药合同的废物，今年带着不屈的精神，进了全明星，东部第五，让无数人震惊；这一夜，二十一岁的特纳和二十一岁的萨博尼斯抢七，二十一岁的特纳，看着最后时刻自己被六犯罚下无法为球队提供帮助时，无能为力的痛哭；奥拉迪波没法拯救球队，再球队输了之后立刻联系训练师，开启了新的征程，走向更加伟大的路；这都是来自于内心强大的竞争本性。 篮球的魅力就是如此——竞争，这种和世界上其他任何职业都一样的东西，不服输。这是最优秀的品质之一，各行各业皆是如此。最后祝愿骑士胜利，步行者来年能更加强大，成长的代价就是如此——残酷，坚韧。","tags":[{"name":"存档","slug":"file","permalink":"http://blog.inbelieve.top/tags/file/"}]},{"title":"Linux上安装git","date":"2018-06-16T09:27:35.000Z","path":"skill/20180616-1.html","text":"centos # 安装yum install git-core# 查看git version# 配置用户名和邮箱git config --global user.name xxxgit config --global user.email xxxx@xx.com# 生成公钥私钥对ssh-keygen -t rsa debian/ubuntu #安装# 安装apt-get install git# 查看git version# 配置用户名和邮箱git config --global user.name xxxgit config --global user.email xxxx@xx.com# 生成公钥私钥对ssh-keygen -t rsa 接下来，你就可以愉快使用git了！","tags":[{"name":"Git","slug":"git","permalink":"http://blog.inbelieve.top/tags/git/"},{"name":"Linux","slug":"linux","permalink":"http://blog.inbelieve.top/tags/linux/"},{"name":"Centos","slug":"centos","permalink":"http://blog.inbelieve.top/tags/centos/"}]},{"title":"git常用命令大全","date":"2018-06-16T09:27:14.000Z","path":"skill/20180616-0.html","text":"本来打算写一篇git命令大全的，但是看到别人也写了一篇，而且挺全面的，也就转过来，他山之石，可以攻玉，希望对大家有所帮助。原文地址：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令 bg2015120901.png 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。* Workspace：工作区* Index / Stage：暂存区* Repository：仓库区（或本地仓库）* Remote：远程仓库 一、新建代码库 # 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件 # 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交 # 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支 # 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签 # 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息 # 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的代码差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog# 从本地master拉取代码更新当前分支：branch 一般为master$ git rebase [branch] 八、远程同步 # 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销 # 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他 # 生成一个可供发布的压缩包$ git archive","tags":[{"name":"Git","slug":"git","permalink":"http://blog.inbelieve.top/tags/git/"}]},{"title":"form-data、x-www-form-urlencoded、raw、binary的区别","date":"2018-03-27T22:07:52.000Z","path":"frontend/arch1.html","text":"form-data:就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型;content-disposition，用来说明字段的一些信息； 由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。 request request x-www-form-urlencoded:就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对，比如,name=admin&amp;password = 123123 request request json:application/json的发送和接收序列化后的 JSON 字符串 服务端： php用file_get_contents拿Post数据。$_POST[‘test’]取不到数据。 然后使用json_decode解码。 原始file_get_contents是字符串？ octet-stream:从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。 request","tags":[{"name":"HTTP","slug":"http","permalink":"http://blog.inbelieve.top/tags/http/"}]},{"title":"免费的编程中文书籍索引","date":"2018-03-21T21:48:00.000Z","path":"resource/arch2.html","text":"语言无关类操作系统 开源世界旅行手册 鸟哥的Linux私房菜 The Linux Command Line (中英文版) Linux 设备驱动 (第三版) 深入分析Linux内核源码 UNIX TOOLBOX Docker中文指南 Docker —— 从入门到实践 Docker入门实战 Docker Cheat Sheet FreeRADIUS新手入门 Mac 开发配置手册 FreeBSD 使用手册 Linux 命令行(中文版) Linux 构建指南 Linux工具快速教程 Linux Documentation (中文版) 嵌入式 Linux 知识库 (eLinux.org 中文版) 理解Linux进程 命令行的艺术 SystemTap新手指南 智能系统 一步步搭建物联网系统 分布式系统 走向分布式 编译原理 《计算机程序的结构和解释》公开课 翻译项目 函数式概念 傻瓜函数编程 计算机图形学 OpenGL 教程 WebGL自学网 Nginx开发从入门到精通 (淘宝团队出品) ginx教程从入门到精通 (PDF版本，运维生存时间出品) OpenResty最佳实践 Apache 中文手册 版本控制 Git教程 git - 简易指南 猴子都能懂的GIT入门 Git 参考手册 Pro Git Pro Git 中文版 (整理在gitbook上) Git Magic GotGitHub Git权威指南 Git Community Book 中文版 Mercurial 使用教程 HgInit (中文版) 沉浸式学 Git Git-Cheat-Sheet GitHub秘籍 Github帮助文档 git-flow 备忘清单 svn 手册 GitHub漫游指南编辑器 Vim中文文档 所需即所获：像 IDE 一样使用 vim Atom飞行手册中文版 Markdown·简单的世界NoSQL NoSQL数据库笔谈 (PDF) Redis 设计与实现 Redis 命令参考 带有详细注释的 Redis 3.0 代码 带有详细注释的 Redis 2.6 代码 The Little MongoDB Book The Little Redis Book Neo4j 简体中文手册 v1.8 Neo4j .rb 中文資源 Disque 使用教程PostgreSQL PostgreSQL 8.2.3 中文文档 PostgreSQL 9.3.1 中文文档MySQL MySQL索引背后的数据结构及算法原理 21分钟MySQL入门教程管理监控 ELKstack 中文指南 Mastering Elasticsearch(中文版) ElasticSearch 权威指南 Elasticsearch 权威指南（中文版 Logstash 最佳实践 Puppet 2.7 Cookbook 中文版项目相关 持续集成（第二版） (译言网) 让开发自动化系列专栏 追求代码质量 selenium 中文文档 Selenium Webdriver 简易教程 約耳談軟體(Joel on Software) Gradle 2 用户指南 Gradle 中文使用文档 编码规范 开源软件架构 GNU make 指南 GNU make 中文手册设计模式 图说设计模式 史上最全设计模式导学目录 design pattern 包教不包会 设计模式 Java 版Web 关于浏览器和网络的 20 项须知 浏览器开发工具的秘密 Chrome 开发者工具中文手册 Chrome扩展开发文档 Grunt中文文档 gulp中文文档 Gulp 入门指南 移动Web前端知识库 正则表达式30分钟入门教程 前端开发体系建设日记 移动前端开发收藏夹 JSON风格指南 HTTP 接口设计指北 前端资源分享（一） 前端资源分享（二） 前端代码规范 及 最佳实践 前端开发者手册 前端工程师手册 w3school教程整理 Wireshark用户手册 一站式学习Wireshark HTTP 下午茶 HTTP/2.0 中文翻译 RFC 7540 - HTTP/2 中文翻译版 http2讲解 3 Web Designs in 3 Weeks大数据 大数据/数据挖掘/推荐系统/机器学习相关资源 面向程序员的数据挖掘指 大型集群上的快速和通用数据处理架构 数据挖掘中经典的算法实现和详细的注释 Spark 编程指南简体中文版编程艺术 程序员编程艺术 每个程序员都应该了解的内存知识(译) 取悦的工序：如何理解游戏其他 OpenWrt智能、自动、透明翻墙路由器教程 SAN 管理入门系列 Sketch 中文手册 深入理解并行编程 程序员的自我修养 Growth: 全栈增长工程师指南语言相关类Android awk程序设计语言 Google Material Design 正體中文版 译本一 译本二 Material Design 中文版 Google Android官方培训课程中文版 Android学习之路 Android开发技术前线(android-tech-frontier) Point-of-AndroidAndroid 一些重要知识点解析整理 Android6.0新特性详解APP Apache Cordova 开发指南AWK awk程序设计语言 awk中文指南C/C++ C/C++ 中文参考手册 (欢迎大家参与在线翻译和校对) C 语言编程透视 C++ 并发编程指南 Linux C编程一站式学习 (宋劲杉, 北京亚嵌教育研究中心) CGDB中文手册 100个gdb小技巧 100个gcc小技巧 ZMQ 指南 How to Think Like a Computer Scientist (中英文版) 跟我一起写Makefile(PDF) GNU make中文手册 GNU make 指南 Google C++ 风格指南 C/C++ Primer 简单易懂的C魔法 Cmake 实践 (PDF版) C++ FAQ LITE(中文版) C++ Primer 5th Answers C++ 并发编程(基于C++11) QT 教程 DevBean的《Qt学习之路2》(Qt5) C++ Template 进阶指南 libuv中文教程 Boost 库中文教程Clojure Clojure入门教程C MSDN C# 中文文档 .NET 类库参考 ASP.NET MVC 5 入门指南 超全面的 .NET GDI+ 图形图像编程教程 .NET控件开发基础CSS 学习CSS布局 通用 CSS 笔记、建议与指导 CSS参考手册 Emmet 文档 前端代码规范 (腾讯 AlloyTeam 团队) HTML和CSS编码规范 Sass Guidelines 中文 CSS3 Tutorial 《CSS3 教程》 MDN HTML 中文文档 MDN CSS 中文文档Dart Dart 语言导览Elixir Elixir编程入门Erlang 21天学通ErlangFortran Fortran77和90/95编程入门Go Go编程基础 Go入门指南 学习Go语言 Go Web 编程 Go实战开发 Network programming with Go 中文翻译版本 Effective Go Go 语言标准库 Revel 框架手册 Java程序员的Golang入门指南 Go命令教程 Go语言博客实践 Go 官方文档翻译 深入解析Go Go语言圣经(中文版)Groovy 实战 Groovy 系列Haskell Real World Haskell 中文版 Haskell趣学指南iOS iOS开发60分钟入门 iOS7人机界面指南 Google Objective-C Style Guide 中文版 iPhone 6 屏幕揭秘 Apple Watch开发初探 马上着手开发 iOS 应用程序 网易斯坦福大学公开课：iOS 7应用开发字幕文件Java Apache Shiro 用户指南 Jersey 2.x 用户指南 Spring Framework 4.x参考文档 Spring Boot参考指南(翻译中) MyBatis中文文档 MyBatis Generator 中文文档 用jersey构建REST服务 Activiti 5.x 用户指 Google Java编程风格指南 Netty 4.x 用户指南 Netty 实战(精髓) REST 实战 Java 编码规范 Apache MINA 2 用户指南 H2 Database 教程 Java Servlet 3.1 规范 JSSE 参考指南 Java开源实现及最佳实践 Java 编程要点 Think JavaJavaScript Google JavaScript 代码风格指南 Google JSON 风格指南 Airbnb JavaScript 规范 JavaScript 标准参考教程（alpha） Javascript编程指南 (源码) javascript 的 12 个怪癖 JavaScript 秘密花园 JavaScript核心概念及实践 《JavaScript 模式》“JavaScript patterns”中译本 命名函数表达式探秘 学用 JavaScript 设计模式 (开源中国) 深入理解JavaScript系列 ECMAScript 6 入门 (作者：阮一峰) JavaScript Promise迷你书 You-Dont-Know-JS(深入JavaScript语言核心机制的系列图书) JavaScript 教程廖雪峰 MDN JavaScript 中文文档 jQuery jQuery 解构 简单易懂的JQuery魔法 How to write jQuery plugin You Don’t Need jQuery 如何实现一个类jQuery Node.js Node入门 七天学会NodeJS Nodejs Wiki Book (繁体中文) express.js 中文文档 koa 中文文档 一起学koa 使用 Express + MongoDB 搭建多人博客 Express框架 Node.js 包教不包会 Learn You The Node.js For Much Win! (中文版) Node debug 三法三例 nodejs中文文档 orm2 中文文档 underscore.js Underscore.js中文文档 backbone.js backbone.js中文文档 backbone.js入门教程 (PDF) Backbone.js入门教程第二版 Developing Backbone.js Applications(中文版) AngularJS AngularJS最佳实践和风格指南 AngularJS中译本 AngularJS入门教程 构建自己的AngularJS 在Windows环境下用Yeoman构建AngularJS项目 zepto.js Zepto.js 中文文档 Sea.js Hello Sea.js React.js React.js 中文文档 React webpack-cookbook React 入门教程 React Native 中文文档(含最新Android内容) Learn React &amp; Webpack by building the Hacker News front page impress.js impress.js的中文教程 CoffeeScript CoffeeScript Cookbook The Little Book on CoffeeScript中文版 CoffeeScript 编码风格指南 TypeScipt TypeScript Handbook ExtJS Ext4.1.0 中文文档 Meteor Discover Meteor Meteor 中文文档 Angular-Meteor 中文教程 Chrome扩展及应用开发LaTeX 一份其实很短的 LaTeX 入门文档 一份不太简短的 LATEX 2ε 介绍（PDF版）LISP ANSI Common Lisp 中文翻譯版 On Lisp 中文翻译版 Yet Another Scheme Tutorial Scheme入门教程 Scheme语言简明教程 Racket bookLua Lua编程入门 Lua 5.1 参考手册 中文翻译 Lua 5.3 参考手册 中文翻译 Lua源码欣赏OCaml Real World OCamlPerl Modern Perl 中文版 Perl 程序员应该知道的事PHP PHP 官方手册 PHP调试技术手册(PDF) PHP之道：php-the-right-way PHP 最佳实践 PHP 开发者实践 深入理解PHP内核 PHP扩展开发及内核应用 CodeIgniter 用户指南 Laravel5 中文文档 Laravel 入门 YiiBook几本Yii框架的在线教程 深入理解 Yii 2.0 Yii 框架中文文檔 简单易懂的PHP魔法 swoole文档及入门教程 Composer 中文网 Slim 中文文档 Lumen 中文文档 PHPUnit 中文文档Prolog 笨办法学PrologPython 廖雪峰 Python 2.7 中文教程 廖雪峰 Python 3 中文教程 简明Python教程 零基础学 Python 第一版 零基础学 Python 第二版 可爱的 Python Python 2.7 官方教程中文版 Python 3.3 官方教程中文版 Python Cookbook 中文版 Python3 Cookbook 中文版 深入 Python 深入 Python 3 PEP8 Python代码风格规范 Google Python 风格指南 中文版 Python入门教程 (PDF) Python的神奇方法指南 笨办法学 Python Python自然语言处理中文版 Python 绘图库 matplotlib 官方指南中文翻译 Scrapy 0.25 文档 ThinkPython ThinkPython 2ed Python快速教程 Python 正则表达式操作指南 python初级教程：入门详解 Twisted 与异步编程入门 TextGrocery 中文 API( 基于svm算法的一个短文本分类 Python 库 ) Requests: HTTP for Humans Pillow 中文文档 PyMOTW 中文版 Python 官方文档中文版 Fabric 中文文档 Beautiful Soup 4.2.0 中文文档 用Python做科学计算 Sphinx 中文文档 精通 Python 设计模式 python 安全编程教程 程序设计思想与方法 知乎周刊·编程小白学Python Scipy 讲义 Python 学习笔记 基础篇 Python 学习笔记 模块篇 Python 标准库 中文版 Python进阶 Python 核心编程 第二版 CPyUG译 Django Django 1.5 文档中文版 正在翻译中 Diango 1.7 文档中文版 正在翻译中，目前只翻译了目录 Django 1.8.2 文档中文版 正在翻译中 Django 最佳实践 Django搭建简易博客教程 The Django Book 中文版 Django 设计模式与最佳实践 Django 网站开发 Cookbook Django Girls 學習指南 Flask Flask 文档中文版 Jinja2 文档中文版 Werkzeug 文档中文版 Flask之旅 Flask 扩展文档汇总 Flask 大型教程 SQLAlchemy 中文文档 web.py web.py 0.3 新手指南 Web.py Cookbook 简体中文版 Tornado Introduction to Tornado 中文翻译 Tornado源码解析 Tornado 4.3 文档中文版R R语言忍者秘笈Ruby Ruby 风格指南 Rails 风格指南 笨方法學 Ruby Ruby on Rails 指南 Ruby on Rails 實戰聖經 Ruby on Rails Tutorial 原书第 3 版 Rails 实践 Rails 5 开发进阶(Beta) Rails 102 编写Ruby的C拓展 Ruby 源码解读 Ruby中的元编程 Puppet 2.7 Cookbook 中文版Rust rust book 中文翻译 rrust primerScala Scala课堂 (Twitter的Scala中文教程) Effective Scala(Twitter的Scala最佳实践的中文翻译) Scala指南Shell Shell脚本编程30分钟入门 Bash脚本15分钟进阶教程 Linux工具快速教程 shell十三问 Shell编程范例Swift The Swift Programming Language 中文版 Swift 语言指南 Stanford 公开课，Developing iOS 8 Apps with Swift 字幕翻译文件读书笔记及其它读书笔记 编译原理（紫龙书）中文第2版习题答案 把《编程珠玑》读薄 Effective C++读书笔记 Golang 学习笔记、Python 学习笔记、C 学习笔记 (PDF) Jsoup 学习笔记 学习笔记: Vim、Python、memcached 图灵开放书翻译计划–C++、Python、Java等 蒂姆·奥莱利随笔 （由译言网翻译，电子版免费） SICP 解题集 精彩博客集合 正则表达式简明参考 中文文案排版指北 Standard C 语言标准函数库速查 (Cheat Sheet) Git Cheatsheet Chs GitBook简明教程 JavaScript语言精粹 制造开源软件 提问的智慧 Markdown 入门参考 AsciiDoc简明指南 背包问题九讲 老齐的技术资料 前端技能汇总 借助开源项目，学习软件开发 前端工作面试问题 leetcode/lintcode题解/算法学习笔记 前端开发笔记本测试相关 移动APP自动化测试优秀框架Appium API Reference V1.2.0 CN 相关链接 链接1","tags":[{"name":"存档","slug":"file","permalink":"http://blog.inbelieve.top/tags/file/"}]}]